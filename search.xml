<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[文字超出长度显示省略号]]></title>
      <url>%2F2017%2F08%2F21%2F%E6%96%87%E5%AD%97%E8%B6%85%E5%87%BA%E7%94%A8%E7%9C%81%E7%95%A5%E5%8F%B7%E8%A1%A8%E7%A4%BA%2F</url>
      <content type="text"><![CDATA[为了保证页面的整洁美观，在很多的时候，我们常需要隐藏超出长度的文字。 以下是超出定宽容器显示省略号的设置方法，原理都一样。 HTML代码： 123&lt;div class="item"&gt; &lt;p class="line-limit"&gt;亲，一行文字太多，显示不下，接下来的文字我要用省略号代替。我可能是超出长度被隐藏的文字&lt;/p&gt;&lt;/div&gt; CSS代码： 123456789.item &#123; background-color: #9cc9ef; max-width: 470px;&#125;.line-limit &#123; overflow: hidden; /*超出隐藏*/ text-overflow: ellipsis; /*文本隐藏部分显示为省略*/ white-space: nowrap; /*文本不换行，这样超出一行的部分被截取，显示...*/&#125; 效果截图：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript 中常见的几种排序算法]]></title>
      <url>%2F2017%2F08%2F18%2Fjs%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[本文学习自《JavaScript数据结构与算法》，记录JavaScript 中常见的几种排序算法，包括冒泡排序，选择排序，插入排序，归并排序和快速排序。详细介绍算法思想，复杂度，算法代码以及示意图演示。 1. 冒泡排序【算法思想】：比较任何两个相邻的项，如果第一个比第二个大，则交换它们。元素项向上移动至正确的顺序，就好像气泡升至表面一样。【O复杂度】：O(n^2)，它在排序算法中最简单，但从运行时间的角度来看，冒泡排序是最差的。【实现代码】： 12345678910111213function bubbleSort(arr) &#123; var len = arr.length; for (var i = 0; i &lt; len; i++) &#123; for (var j = 0; j &lt; len-1-i; j++) &#123; if(arr[j] &gt; arr[j+1]) &#123; var temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125; return arr; &#125; 【排序示意图】：[5, 4, 3, 2, 1] 2. 选择排序【算法思想】：原址比较排序算法，找到数据结构中的最小值并将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类推。【O复杂度】：O(n^2)，和冒泡排序一样，它包含嵌套的两个循环，这导致了二次方的复杂度。【实现代码】： 12345678910111213141516171819function selectionSort(arr) &#123; var len = arr.length; var indexMin; for (var i = 0; i &lt; len-1; i++) &#123; indexMin = i; for (var j = i; j &lt; len; j++) &#123; if(arr[indexMin] &gt; arr[j]) &#123; indexMin = j; &#125; &#125; if (i != indexMin) &#123; var temp = arr[i]; arr[i] = arr[indexMin]; arr[indexMin] = temp; &#125; &#125; return arr;&#125; 【排序示意图】：[5, 4, 3, 2, 1] 数组底部的箭头指示出当前迭代轮寻找最小值的数组范围，示意图中的每一步则表示外循环。 3. 插入排序【算法思想】：每次排一个数组项，以此方式构建最后的排序数组。假定第一项已经排序了，接着，它和第二项进行比较，第二项是应该待在原位还是插到第一项之前呢？这样，头两项就已正确排序，接着和第三项比较（它是该插入到第一、第二还是第三的位置呢？），以此类推。【O复杂度】：排序小型数组时，此算法比选择排序和冒泡排序性能要好。。【实现代码】： 12345678910111213function insertionSort(arr) &#123; var len = arr.length; for (var i = 1; i &lt; len; i++) &#123; // i从1开始，默认第一项已排好序 var j = i; var temp = arr[i]; // 保存待插入项 while(j &gt; 0 &amp;&amp; arr[j-1] &gt; temp) &#123; arr[j] = arr[j-1]; j--; &#125; arr[j] = temp; &#125; return arr;&#125; 【排序示意图】：[3, 5, 1, 4, 2] (1) 3 已被排序，所以我们从数组第二个值5开始。3比5小，所以5待在原位（数组的第二位）。3和5排序完毕。(2) 下一个待排序和插到正确位置上去的值是1（目前在数组的第三位）。5比1大，所以5被移至第三位去了。我们得分析1是否应该被插入到第二位——1比3大吗？不，所以3被移到第二位去了。接着，我们得证明1 应该插入到数组的第一位上。因为0是第一个位置且没有负数位，所以1必须被插入到第一位。1、3、5三个数字已经排序。(3) 4应该在当前位置（索引3 ）还是要移动到索引较低的位置上呢？4 比5 小，所以5 移动到索引3 位置上去。那么应该把4 插到索引2 的位置上去吗？4 要比3 大，所以4 插入到数组的位置3 上。(4) 下一个待插入的数字是2 （数组的位置4）。5比2大，所以5移动至索引4。4比2 大，所以4也得移动（位置3）。3也比2大，所以3还得移动。1比2小，所以2插入到数组的第二位置上。至此，数组已排序完成。 4. 归并排序【算法思想】：是一种分治算法。其思想是将原始数组切分成较小的数组，直到每个小数组只有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。【O复杂度】：O(nlog^n)，归并排序性能不错。【实现代码】： 12345678910111213141516171819202122232425262728293031323334function mergeSort(arr) &#123; return mergeSortRec(arr);&#125;function mergeSortRec(arr) &#123; var len = arr.length; if (len == 1) &#123;return arr;&#125; var mid = Math.floor(len / 2), // 中值 left = arr.slice(0, mid), // 左数组 right = arr.slice(mid, len);// 右数组 return merge(mergeSortRec(left), mergeSortRec(right));&#125;function merge(left, right) &#123; var res = [], lenLeft = left.length, lenRight = right.length, il = 0, ir = 0; while(il &lt; lenLeft &amp;&amp; ir &lt; lenRight) &#123; if(left[il] &lt; right[ir]) &#123; res.push(left[il++]); &#125;else&#123; res.push(right[ir++]); &#125; &#125; while(il &lt; lenLeft) &#123; res.push(left[il]); &#125; while(ir &lt; lenRight) &#123; res.push(right[ir]); &#125; return res;&#125; 【排序示意图】：[8, 7, 6, 5, 4, 3, 2, 1] 可以看到，算法首先将原始数组分割直至只有一个元素的子数组，然后开始归并。归并过程也会完成排序，直至原始数组完全合并并完成排序。 5. 快速排序【算法思想】：快速排序也许是最常用的排序算法了。和归并排序一样，快速排序也使用分治的方法，将原始数组分为较小的数组（但它没有像归并排序那样将它们分割开）。【O复杂度】：它的复杂度为O(nlog^n) ，且它的性能通常比其他的复杂度为O(nlog^n) 的排序算法要好。【具体做法】：(1) 首先，从数组中选择中间一项作为主元。(2) 创建两个指针，左边一个指向数组第一个项，右边一个指向数组最后一个项。移动左指针直到我们找到一个比主元大的元素，接着，移动右指针直到找到一个比主元小的元素，然后交换它们，重复这个过程，直到左指针超过了右指针。这个过程将使得比主元小的值都排在主元之前，而比主元大的值都排在主元之后。这一步叫作划分操作。(3) 接着，算法对划分后的小数组（较主元小的值组成的子数组，以及较主元大的值组成的子数组）重复之前的两个步骤，直至数组已完全排序。 【实现代码】： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function quickSort(arr)&#123; return quick(arr, 0, arr.length-1); &#125;; // 声明一个主方法来调用递归函数,传递待排序数组，以及索引0及其最末的位置function quick(arr, left, right)&#123; var index; // 将子数组分离为较小值数组和较大值数组的索引 if (arr.length &gt; 1) &#123; // 如果数组的长度比1大（因为只有一个元素的数组必然是已排序了的) index = partition(arr, left, right); // 执行partition操作（第一次调用是针对整个数组） // 划分后的子数组（较主元小的值组成的子数组，以及较主元大的值组成的子数组）递归调用quick函数 if (left &lt; index - 1) &#123; quick(arr, left, index - 1); &#125; if (index &lt; right) &#123; quick(arr, index, right); &#125; &#125; &#125;;// 划分过程function partition(arr, left, right) &#123; var pivot = arr[Math.floor((right + left) / 2)], // 选择中间项作为主元 i = left, // left指针 j = right; // right指针 while (i &lt;= j) &#123; // 只要left和right 指针没有相互交错，就执行划分操作 while (arr[i] &lt; pivot) &#123; // 移动left指针直到找到一个元素比主元大 i++; &#125; while (arr[j] &gt; pivot) &#123; // 移动right指针直到我们找到一个元素比主元小 j--; &#125; // 当左指针指向的元素比主元大且右指针指向的元素比主元小，并且此时左指针索引没有右指针索引大 if (i &lt;= j) &#123; swapQuickStort(arr, i, j); // 交换它们，然后移动两个指针，并重复此过程 i++; j--; &#125; &#125; return i; // 在划分操作结束后，返回左指针的索引&#125;; function swapQuickStort(arr, index1, index2)&#123; var aux = arr[index1]; arr[index1] = arr[index2]; arr[index2] = aux; &#125;; 【排序示意图】：[3, 5, 1, 6, 4, 7, 2] 注：文中图片引自《JavaScript数据结构与算法》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《剑指offer》JavaScript版——(5)用两个栈实现队列]]></title>
      <url>%2F2017%2F07%2F24%2F%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B%E2%80%94%20JavaScript%EF%BC%885%EF%BC%89%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%2F</url>
      <content type="text"><![CDATA[题目：用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 基础知识点： 栈（stack）又名堆栈，它是一种运算受限的线性表。其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。 队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作。进行插入操作的端称为队尾，进行删除操作的端称为队头。 思路：入队：将元素进栈1;出队：判断栈2是否为空，如果为空，则将栈1中所有元素pop，并push进栈2，栈2出栈； 如果不为空，栈2直接出栈。 12345678910111213var stack1 = [];var stack2 = [];function push(node)&#123; stack1.push(node);&#125;function pop()&#123; if(stack2.length == 0)&#123; while(stack1.length &gt; 0)&#123; stack2.push(stack1.pop()); &#125; &#125; return stack2.pop();&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《剑指offer》JavaScript版——(4)重建二叉树]]></title>
      <url>%2F2017%2F07%2F24%2F%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B%E2%80%94%20JavaScript%EF%BC%884%EF%BC%89%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
      <content type="text"><![CDATA[题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 思路：前序遍历的第一个节点就是根节点，中序遍历根节点的左边在根节点的左子树，右边在根节点的右子树。 12345678910111213141516171819202122/* function TreeNode(x) &#123; this.val = x; this.left = null; this.right = null;&#125; */function reConstructBinaryTree(pre, vin) &#123; if(pre.length == 0 || vin.length == 0) &#123; return null; &#125; var idx = vin.indexOf(pre[0]); // 根节点的索引 var vinleft = vin.slice(0, idx); // 中序左子树 var vinright = vin.slice(idx+1); // 中序右子树 var preleft = pre.slice(1,idx+1); // 前序左子树 var preright = pre.slice(idx+1); // 前序右子树 return &#123; val: pre[0], left: reConstructBinaryTree(preleft, vinleft), // 递归 right: reConstructBinaryTree(preright, vinright) &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《剑指offer》JavaScript版——(3)从尾到头打印链表]]></title>
      <url>%2F2017%2F07%2F24%2F%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B%E2%80%94%20JavaScript%EF%BC%883%EF%BC%89%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8%2F</url>
      <content type="text"><![CDATA[题目：输入一个链表，从尾到头打印链表每个节点的值。 基础知识点：链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 思路：定义一个数组，将链表的节点依次从头部unshift进数组，将数组输出。 12345678910111213/*function ListNode(x)&#123; this.val = x; this.next = null;&#125;*/function printListFromTailToHead(head) &#123; var arr = []; if(!head) return false; while(head) &#123; arr.unshift(head.val); head = head.next; &#125; return arr;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《剑指offer》JavaScript版——(2)替换空格]]></title>
      <url>%2F2017%2F07%2F23%2F%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B%E2%80%94%20JavaScript%EF%BC%882%EF%BC%89%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC%2F</url>
      <content type="text"><![CDATA[题目：请实现一个函数，将一个字符串中的空格替换成%20。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 思路：使用正则表达式，调用replace函数。\s匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[\f\n\r\t\v]。 AC代码： 12345function replaceSpace(str)&#123; //return str.replace(/\s+?/g, "%20"); // \s+? 非贪婪匹配 return str.replace(/\s/g, "%20");&#125; 演示：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《剑指offer》JavaScript版——(1)二维数组中的查找]]></title>
      <url>%2F2017%2F07%2F23%2F%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B%E2%80%94%20JavaScript%EF%BC%881%EF%BC%89%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%2F</url>
      <content type="text"><![CDATA[题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 思路： 有序矩阵，从左下角的元素开始，如果数组元素比target小，则上移；如果比target大，则右移。 AC代码： 123456789101112131415function Find(target, array)&#123; var row = array.length; var col = array[0].length; for(var i = row-1,j = 0;(i &gt;= 0)&amp;&amp;(j &lt; col);)&#123; if(target &gt; array[i][j])&#123; j++; &#125;else if(target &lt; array[i][j])&#123; i--; &#125;else&#123; return true; &#125; &#125; return false;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[腾讯课堂IMWeb备战秋招-Day04]]></title>
      <url>%2F2017%2F07%2F23%2F%E8%85%BE%E8%AE%AF%E8%AF%BE%E5%A0%82IMWeb%E5%89%8D%E7%AB%AF%E6%B1%82%E8%81%8C%E8%AE%AD%E7%BB%83%E8%90%A5-Day04%2F</url>
      <content type="text"><![CDATA[知识点：null和undefined、new操作符、内存泄漏、Node的优缺点。 一、经典面试题13. null和undefined的区别？null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象, 转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。当声明的变量还未被初始化时，变量的默认值为undefined。 1.null表示”没有对象”，即该处不应该有值。典型用法是：① 作为函数的参数，表示该函数的参数不是对象。② 作为对象原型链的终点。 2.undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：① 变量被声明了，但没有赋值时，就等于undefined。② 调用函数时，应该提供的参数没有提供，该参数等于undefined。③ 对象没有赋值的属性，该属性的值为undefined。④ 函数没有返回值时，默认返回undefined。 14. new操作符具体干了什么呢?① 创建一个空对象，并且this 变量引用该对象，同时还继承了该函数的原型。② 属性和方法被加入到 this 引用的对象中。③ 新创建的对象由 this 所引用，并且最后隐式的返回this 。 15. 哪些操作会造成内存泄漏？内存泄漏指任何对象在不再拥有或需要它之后仍然存在。垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。 setTimeout的第一个参数使用字符串而非函数的话，会引发内存泄漏。 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）。 16. 对Node的优点和缺点提出了自己的看法？优点：因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求， 因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。 此外，与Node代理服务器交互的客户端代码是由javascript语言编写的， 因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。 缺点：Node是一个相对新的开源项目，所以不太稳定，它总是一直在变， 而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。 二、编程题1. 颜色字符串转换题目：将 rgb 颜色字符串转换为十六进制的形式，如 rgb(255, 255, 255) 转为 #ffffff； rgb 中每个 , 后面的空格数量不固定 十六进制表达式使用六位小写字母 如果输入不符合 rgb 格式，返回原始输入 12345678function rgb2hex(sRGB) &#123; return sRGB.replace(/^rgb\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)\)$/,function($0,$1,$2,$3)&#123; return '#'+toHex($1)+toHex($2)+toHex($3); // $0:正则匹配的整个字符串; $1, $2, $3:捕获项 &#125;); function toHex(str)&#123; return ('0'+(+str).toString(16)).slice(-2); &#125;&#125; 2. 将字符串转为驼峰格式题目：将类似 background-image 这种通过 - 连接的字符，转换成 backgroundImage 驼峰格式。 以 - 为分隔符，将第二个起的非空单词首字母转为大写 -webkit-border-image 转换后的结果为 webkitBorderImage 12345678910111213141516171819202122function cssStyle2DomStyle(sName) &#123; var result = sName.replace(/^-/,'').split('-'); for (var i = 1, len = result.length; i &lt; len; i++) &#123; result[i] = result[i].replace(/^\w/, function(s) &#123; return s.toUpperCase(); &#125;) &#125; return result.join('');&#125;function cssStyle2DomStyle(sName) &#123; var arr = sName.split(''); if(arr.indexOf('-') == 0) // 判断第一个是不是 '-'，是的话就删除 arr.splice(0,1); for(var i=0; i&lt;arr.length; i++)&#123; // 处理剩余的'-' if(arr[i] == '-')&#123; arr.splice(i,1); arr[i] = arr[i].toUpperCase(); &#125; &#125; return arr.join('');&#125; 3. 求二次方题目：为数组 arr 中的每个元素求二次方。不要直接修改数组 arr，结果返回新的数组1234567891011121314151617181920212223/* map 方法 */function square(arr) &#123; if(Array.prototype.map) &#123; return arr.map(function(item, index, array) &#123; return item * item; &#125;) &#125;else &#123; var newArr = []; for(var i = 0, len = arr.length; i &lt; len; i++) &#123; newArr.push(arr[i] * arr[i]); &#125; return newArr; &#125;&#125;/* forEach 方法 */function square(arr) &#123; var a = []; //声明一个新的数组存放结果 arr.forEach(function(e)&#123; a.push(e*e); //将arr中的每一个元素求平方后，加入到a数组中 &#125;); return a;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[腾讯课堂IMWeb备战秋招-Day03]]></title>
      <url>%2F2017%2F07%2F21%2F%E8%85%BE%E8%AE%AF%E8%AF%BE%E5%A0%82IMWeb%E5%89%8D%E7%AB%AF%E6%B1%82%E8%81%8C%E8%AE%AD%E7%BB%83%E8%90%A5-Day03%2F</url>
      <content type="text"><![CDATA[知识点：伪数组、浏览器本地存储、线程与进程、减少页面加载时间的方法。 一、经典面试题9. 什么是伪数组？如何将伪数组转化为标准数组？1）伪数组（类数组）一般具有以下特点： 按索引方式存储数据； 具有length属性； 没有数组的push、shift、pop等方法; function的arguments对象，还有getElementsByTagName、ele.childNodes等返回的NodeList对象，或者自定义的某些对象，都可以是伪数组。 2）如何将伪数组转化为标准数组？ ① 使用Array.prototype.slice.call(); ② 使用[].slice.call()，本质上与第一种方法是一样的，但第一种方式效率更高。 ③ 使用ES6中Array.from方法; 10. 浏览器本地存储?在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供localStorage来取代globalStorage。html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。 1. 会话级别的本地存储：sessionStorage 通过此对象可以直接操作存储在浏览器中的会话级别的WebStorage。存储在sessionStorage中的数据首先是Key-Value形式的，另外就是它跟浏览器当前会话相关，当会话结束后，数据会自动清除，跟未设置过期时间的Cookie类似。 sessionStorage提供了四个方法来辅助我们进行对本地存储做相关操作。 setItem(key,value)：添加本地存储数据。两个参数，非常简单就不说了。 getItem(key)：通过key获取相应的Value。 removeItem(key)：通过key删除本地数据。 clear()：清空数据。 12345678&lt;script type="text/javascript"&gt; // 添加key-value 数据到 sessionStorage sessionStorage.setItem("demokey", "http://blog.itjeek.com"); var dt = sessionStorage.getItem("demokey"); // 通过key来获取value alert(dt); sessionStorage.clear(); // 清空所有的key-value数据。 alert(sessionStorage.length);&lt;/script&gt; 2. 永久本地存储：localStorage 数据不会随着Http请求发送到后台服务器，而且存储数据的大小几乎不用考虑，因为在HTML5的标准中要求浏览器至少要支持到4MB。所以，这完全是颠覆了Cookie的限制，为Web应用在本地存储复杂的用户痕迹数据提供非常方便的技术支持。localStorage的常用的方法，基本上跟sessionStorage是一致的。 11. 线程与进程的区别?一个程序至少有一个进程,一个进程至少有一个线程；线程的划分尺度小于进程，使得多线程程序的并发性高；线程是独立调度的基本单位, 进程是拥有资源的基本单位；进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率； 线程在执行过程中与进程还是有区别的: 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。 12. 请说出三种减少页面加载时间的方法。 优化图片 图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方） 优化CSS（压缩合并css，如 margin-top, margin-left…) 网址后加斜杠 标明图片的高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。 当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了） 减少http请求（合并文件，合并图片） 二、编程题1. 找出数组 arr 中重复出现过的元素123456789function duplicates(arr) &#123; var a = []; for (var i = 0; i &lt; arr.length-1; i++) &#123; for (var j = i + 1; j &lt; arr.length; j++) &#123; arr[i] == arr[j] &amp;&amp; a.indexOf(arr[i]) == -1 &amp;&amp; a.push(arr[i]); &#125; &#125; return a;&#125; 2. 时间格式化输出1234567891011121314151617181920function formatDate(t,str)&#123; var obj = &#123; yyyy:t.getFullYear(), yy:(""+ t.getFullYear()).slice(-2), M:t.getMonth()+1, MM:("0"+ (t.getMonth()+1)).slice(-2), d:t.getDate(), dd:("0" + t.getDate()).slice(-2), H:t.getHours(), HH:("0" + t.getHours()).slice(-2), h:t.getHours() % 12, hh:("0"+t.getHours() % 12).slice(-2), m:t.getMinutes(), mm:("0" + t.getMinutes()).slice(-2), s:t.getSeconds(), ss:("0" + t.getSeconds()).slice(-2), w:['日', '一', '二', '三', '四', '五', '六'][t.getDay()] &#125;; return str.replace(/([a-z]+)/ig,function($1)&#123;return obj[$1]&#125;);&#125; 3. 斐波那契数列123456function fibonacci(n) &#123; if (n == 1 || n == 2) &#123; return 1; &#125; return fibonacci(n-1)+fibonacci(n-2);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[腾讯课堂IMWeb前端求职训练营-Day02]]></title>
      <url>%2F2017%2F07%2F20%2F%E8%85%BE%E8%AE%AF%E8%AF%BE%E5%A0%82IMWeb%E5%89%8D%E7%AB%AF%E6%B1%82%E8%81%8C%E8%AE%AD%E7%BB%83%E8%90%A5-Day02%2F</url>
      <content type="text"><![CDATA[知识点：一个完整的HTTP事务、Web攻击技术、Ajax、优雅降级和渐进增强。 一、经典面试题5. 一次完整的HTTP事务是怎样的一个过程？基本流程： a. 域名解析 b. 发起TCP的3次握手 c. 建立TCP连接后发起http请求 d. 服务器端响应http请求，浏览器得到html代码 e. 浏览器解析html代码，并请求html代码中的资源 f. 浏览器对页面进行渲染呈现给用户 6. 你所了解到的Web攻击技术?1）XSS（Cross-Site Scripting，跨站脚本攻击）：指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或者JavaScript进行的一种攻击。 2）SQL注入攻击。 3）CSRF（Cross-Site Request Forgeries，跨站点请求伪造）：指攻击者通过设置好的陷阱，强制对已完成的认证用户进行非预期的个人信息或设定信息等某些状态更新。 7. Ajax是什么? Ajax的交互模型? 同步和异步的区别? 如何解决跨域问题?1）Ajax是什么 ajax是异步的 JavaScript 和 XML。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 2）Ajax的交互模型 1–启动 获取XMlHttpRequest对象 2–open 打开url通道，并设置异步传输 3–send 发送数据到服务器 4–服务器接受数据并处理，处理完成后返回结果 5–客户端接收服务器端返回 3）同步和异步的区别 同步：脚本会停留并等待服务器发送回复然后再继续 异步：脚本允许页面继续其进程并处理可能的回复 4）Ajax跨域的解决方法 如果在A网站中，我们希望使用Ajax来获得B网站中的特定内容，如果A网站与B网站不在同一个域中，那么就出现了跨域访问问题。 IE对于跨域访问的处理是，弹出警告框，提醒用户。如果用户将该网站纳入可信任网站，或者调低安全级别，那么这个问题IE就不会在提醒你。 FireFox等其它非微软的浏览器遇到跨域访问，则解决方案统一是拒绝访问。几个可行的方案： Web代理的方式。 on-Demand方式 iframe方式。 用户本地转储方式 8.什么叫优雅降级和渐进增强？“都关注于同一网站在不同设备里不同浏览器下的表现程度。” 渐进增强 ( progressive enhancement )： 针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级( graceful degradation )： 一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 区别： a. 优雅降级是从复杂的现状开始，并试图减少用户体验的供给 ； b. 渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要 ； c. 降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带； 二、编程题4. 末尾添加元素题目：在数组 arr 末尾添加元素 item。不要直接修改数组 arr，结果返回新的数组。123456789101112131415161718192021/* 常规方法 */function append(arr, item) &#123; var newArr = []; for(var i = 0, len = arr.length; i &lt; len; i++)&#123; newArr.push(arr[i]); &#125; newArr.push(item); return newArr;&#125;/* slice 方法*/function append(arr, item) &#123; var newArr = arr.slice(0); // slice(start, end（可选）); 返回部分数组，不修改原数组。 newArr.push(item); return newArr;&#125;/* concat 方法*/function append(arr, item) &#123; return arr.concat(item); // 数组合并，不改变原数组。&#125; 5. 删除数组的第一个元素题目：删除数组 arr 第一个元素。不要直接修改数组 arr，结果返回新的数组。12345function curtail(arr) &#123; var newArr = arr.slice(0); newArr.shift(); // unshift：头部添加；shift：头部删除。 return newArr;&#125; 6. 根据idx和item添加元素题目：在数组 arr 的 index 处添加元素 item。不要直接修改数组 arr，结果返回新的数组。123456789/* * splice(idx, num, item)；idx：要删除的起始位置；num（可选）：要删除的个数； * item（可选）：要添加的项；返回被删除的元素；修改原数组。 */function insert(arr, item, index) &#123; var newArr = arr.slice(0); newArr.splice(index, 0, item); return newArr;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES5中新增的Array方法——forEach()]]></title>
      <url>%2F2017%2F07%2F19%2FES5%E4%B8%AD%E6%96%B0%E5%A2%9E%E7%9A%84Array%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[forEach是Array新方法中最基本的一个，用于遍历，循环。 forEach()方法1. 语法：1array.forEach(callback[, thisObject]) 2. 参数：callback： 用来测试每个元素的回调函数。callback被调用时传入三个参数：元素值，元素的索引，原数组。 thisObject： 执行 callback 时使用的 this 值，为可选参数。如果省略该参数，则 callback 被调用时的 this 值，在非严格模式下为全局对象（浏览器中为window），在严格模式下传入 undefined。 3. 实例：举例1：数组求和 123456// 只关心数组元素的值，可以编写只有一个参数的函数，额外的参数将忽略var sum = 0;[1,2,3,4].forEach(value) &#123; sum += value;&#125;);console.log(sum); // 10 举例2：每个数组元素的值自加1 12345// 关注数组元素的值，索引以及数组本身[1,2,3,4].forEach(function (item, idx, arr) &#123; arr[idx] = item + 1;&#125;);console.log(arr); // [2,3,4,5] 举例3：指定this的值 123456789101112131415161718192021var database = &#123; users: ["张含韵", "江一燕", "李小璐"], sendEmail: function (user) &#123; if (this.isValidUser(user)) &#123; console.log("你好，" + user); &#125; else &#123; console.log("抱歉，"+ user +"，你不是本家人"); &#125; &#125;, isValidUser: function (user) &#123; return /^张/.test(user); // 正则匹配张姓 &#125;&#125;;// 给每个人发邮件database.users.forEach(database.sendEmail, database); // 使用database代替this// 结果：// 你好，张含韵// 抱歉，江一燕，你不是本家人// 抱歉，李小璐，你不是本家 举例4：forEach不会遍历“空元素” 123var arr = [1,,,3]; // 未赋值元素的值为undefinedconsole.log(arr.length); // 数组长度仍为4arr.forEach(console.log); // 遍历结果只打印1和3 5. IE6-8兼容扩展123456789if (typeof Array.prototype.forEach != "function") &#123; Array.prototype.forEach = function (fn, context) &#123; for (var i = 0, len = this.length; i &lt; len; i++) &#123; if (typeof fn === "function" &amp;&amp; Object.prototype.hasOwnProperty.call(this, i)) &#123; fn.call(context, this[i], i, this); // fn.apply(context, [this[i], i, this]); &#125; &#125; &#125;;&#125; 6. 终止循环forEach()无法在所有元素都传递给调用的函数之前终止遍历，也就是说，没有像for循环中使用的相应的break语句。如果要提前终止，必须把forEach()方法放在一个try块中，并能抛出一个异常。如果forEach()调用的函数抛出foreach.break异常，循环会提前终止。 12345678function foreach(a,f,t) &#123; try &#123;a.forEach(f,t);&#125; catch(e) &#123; if(e === foreach.break) return; else throw e; &#125;&#125;foreach.break = new Error("StopIteration");]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[腾讯课堂IMWeb前端求职训练营-Day01]]></title>
      <url>%2F2017%2F07%2F19%2F%E8%85%BE%E8%AE%AF%E8%AF%BE%E5%A0%82IMWeb%E5%89%8D%E7%AB%AF%E6%B1%82%E8%81%8C%E8%AE%AD%E7%BB%83%E8%90%A5-Day01%2F</url>
      <content type="text"><![CDATA[知识点：盒子模型、src和href的区别、同步和异步、Dom节点操作。 一、经典面试题1. 什么是盒子模型？ 盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border) 两种: 标准 W3C 盒子模型、IE 盒子模型 区别：IE的content部分包含了 border 和 padding 2. 简述一下src与href的区别?href指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，用于超链接。 src是指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。 3. 简述同步和异步的区别?同步是阻塞模式，异步是非阻塞模式。 同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去； 异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。 举个例子：普通B/S模式（同步）AJAX技术（异步） 同步：提交请求 -&gt; 等待服务器处理（这个期间客户端浏览器不能干任何事）-&gt; 处理完毕返回 异步：请求通过事件触发 -&gt; 服务器处理（这是浏览器仍然可以作其他事情）-&gt; 处理完 4. 怎样添加、移除、移动、复制、创建和查找节点？1）创建新节点 createDocumentFragment() //创建一个DOM片段 createElement() //创建一个具体的元素 createTextNode() //创建一个文本节点 2）添加、移除、替换、插入 appendChild() //添加 removeChild() //移除 replaceChild() //替换 insertBefore() //插入 3）查找 getElementsByTagName() //通过标签名称 getElementsByName() //通过元素的Name属性的值 getElementById() //通过元素Id，唯一性 二、编程题1. 查找数组元素位置123456789101112function indexOf(arr, item)&#123; if(Array.prototype.indexOf)&#123; return arr.indexOf(item); &#125;else&#123; for(var i = 0, len = arr.length; i &lt; len; i++)&#123; if(arr[i] === item)&#123; return i; &#125; &#125; &#125; return -1;&#125; 2. 求和1234567891011121314151617181920212223242526272829303132333435363738394041// 递归function sum(arr) &#123; var len = arr.length; if(len == 0)&#123; return 0; &#125; else if (len == 1)&#123; return arr[0]; &#125; else &#123; return arr[0] + sum(arr.slice(1)); &#125;&#125;// 常规循环function sum(arr) &#123; var s = 0; for (var i = arr.length-1; i &gt;= 0; i--)&#123; s += arr[i]; &#125; return s;&#125;// 函数式编程 map-reducefunction sum(arr) &#123; return arr.reduce(function(prev, curr, idx, arr)&#123; return prev + curr; &#125;);&#125;// forEach遍历function sum(arr) &#123; var s = 0; arr.forEach(function(val, idx, arr) &#123; s += val; &#125;); return s;&#125;;// evalfunction sum(arr) &#123; return eval(arr.join("+"));&#125; 3. 移除数组中与item相等的元素12345678910111213141516171819// 常规循环function remove(arr,item)&#123; var newArr = []; for(var i = 0, len = arr.length; i &lt; len; i++)&#123; if(arr[i] != item)&#123; newArr.push(arr[i]); &#125; &#125; return newArr;&#125;// filterfunction remove(arr,item)&#123; return arr.filter(function(s)&#123; if(s != item)&#123; return s; &#125; &#125;)；&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iframe 标签嵌套页面]]></title>
      <url>%2F2017%2F05%2F18%2Fiframe%E5%B5%8C%E5%A5%97%E9%A1%B5%E9%9D%A2%2F</url>
      <content type="text"><![CDATA[我们常常会希望将某种小效果可以直接在文档中显示，而不是通过一个预览外链来查看效果，iframe 元素就可以实现，它会创建包含另外一个文档的内联框架（即行内框架），iframe相当于浏览器里面有个小浏览器，在这个小浏览器中，打开另一个网页。可根据自己的需求自行设置frameborder及scrolling等属性。 1. 属性有标记的是h5新属性 2.实例本博客使用markdown编写，只需要在内容中嵌入iframe标签即可。 123&lt;iframe src="https://wenhuiyang-luck.github.io/jquery-plugin/手风琴/index.html" width="100%" height="400px" frameborder="0" scrolling="no"&gt;&lt;/iframe&gt;&lt;p&gt;一些老的浏览器不支持 iframe。&lt;/p&gt;&lt;p&gt;如果得不到支持，iframe 是不可见的。&lt;/p&gt; 效果如下：点击试试手风琴效果吧]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[天猫仿站：4产品页面——基本详情]]></title>
      <url>%2F2017%2F05%2F16%2F%E5%A4%A9%E7%8C%AB%E4%BB%BF%E7%AB%99%EF%BC%9A4%E4%BA%A7%E5%93%81%E9%A1%B5%E9%9D%A2%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E8%AF%A6%E6%83%85%2F</url>
      <content type="text"><![CDATA[产品页面之基本详情页中用到的“左边固定，右边自动占满”布局。相应的写一“左右固定，中间自适应”布局。 预览地址 1. 左边固定，右边自动占满1234567891011121314&lt;style&gt;.left&#123; width:200px; float:left; background-color:pink &#125;.right&#123; overflow:hidden; background-color:lightskyblue; &#125;&lt;/style&gt;&lt;div class="left"&gt;左边固定宽度&lt;/div&gt;&lt;div class="right"&gt;右边自动填满&lt;/div&gt; 效果预览 2. 左右固定，中间自适应的布局（浮动）1234567891011121314151617181920&lt;style&gt;.left&#123; width:200px; float:left; background-color:pink &#125;.right&#123; width:200px; float:right; background-color:pink &#125;.center &#123; margin:0 200px; background-color:lightblue&#125;&lt;/style&gt; &lt;div class="left"&gt;左边固定宽度&lt;/div&gt;&lt;div class="right"&gt;右边固定宽度&lt;/div&gt;&lt;div class="center"&gt;中间自适应&lt;/div&gt; 效果预览 这里需要注意三个div的顺序：左-右-中，中间的div最后写，如果写在中间，会发生什么呢？ 我来瞧瞧发生了什么 可以看见最后一个div掉下去了，这是因为中间的div没有设置浮动，放在中间div后面的div会换行。下面介绍用position定位实现这种布局。 3. 左右固定，中间自适应的布局（定位）12345678910111213141516171819202122232425262728&lt;style&gt;* &#123; padding:0; margin:0;&#125;.left&#123; position: absolute; left: 0; top: 0; width: 200px; background-color: pink; &#125;.center&#123; margin: 0 200px; background-color: lightblue; &#125;.right&#123; position: absolute; top: 0; right: 0; width: 200px; background-color: pink; &#125;&lt;/style&gt; &lt;div class="left"&gt;左边固定宽度&lt;/div&gt;&lt;div class="center"&gt;中间自适应&lt;/div&gt;&lt;div class="right"&gt;右边固定宽度&lt;/div&gt; 效果预览 这种布局就和div的顺序无关了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[天猫仿站：3分类页面——排序和价格]]></title>
      <url>%2F2017%2F05%2F14%2F%E5%A4%A9%E7%8C%AB%E4%BB%BF%E7%AB%99%EF%BC%9A3%E5%88%86%E7%B1%BB%E9%A1%B5%E9%9D%A2%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F%E5%92%8C%E4%BB%B7%E6%A0%BC%2F</url>
      <content type="text"><![CDATA[分类页面之排序和价格页面的布局。 预览地址 1. HTML结构1234567891011121314151617181920&lt;table class="categorySortBarTable categorySortTable"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td class="grayColumn"&gt;&lt;a href="#"&gt;综合&lt;span class="glyphicon glyphicon-arrow-down"&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href="#"&gt;人气&lt;span class="glyphicon glyphicon-arrow-down"&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href="#"&gt;新品&lt;span class="glyphicon glyphicon-arrow-down"&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href="#"&gt;销量&lt;span class="glyphicon glyphicon-arrow-down"&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href="#"&gt;价格&lt;span class="glyphicon glyphicon-resize-vertical"&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;table class="categorySortBarTable"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;&lt;input type="text" placeholder="请输入" class="sortBarPrice beginPrice"&gt;&lt;/td&gt; &lt;td class="grayColumn priceMiddleColumn"&gt;-&lt;/td&gt; &lt;td&gt;&lt;input type="text" placeholder="请输入" class="sortBarPrice endPrice"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 2. 表格布局要实现上述效果中显示的，使排序项排列在一行，有多种方式，如float，inline，inline-block。此处，我们要实现的效果不仅是排列在一行，此外每个排序项还需要边框，倘若不使用表格来做，而是使用span的border样式来做边框，那么相邻的两个span的边框会挨再一起，就是二倍宽度，看上去过粗。 为了解决过粗的问题，需要对每个span进行仅仅设置左边框，或者右边框，显而易见，此时增加了设置样式的复杂度。而使用table，只需要为td设置border边框，就可以达到效果。 容易很多，维护起来也更简单。 12345678910table.categorySortBarTable &#123; border-collapse: collapse; /*单元格之间没有空隙*/ display: inline-block; /*显示为内联，既可以设置大小，又能够不换行*/&#125;table.categorySortBarTable td &#123; height: 17px; font-size: 12px; border: 1px solid #ccc; padding: 3px;&#125; 关于border-collapse属性：border-collapse: separate(默认,边框分隔) | collapse(边框合并) 12345678910111213141516171819202122&lt;style&gt;table.t1&#123; border-collapse:separate;&#125; table.t2&#123; border-collapse:collapse;&#125;&lt;/style&gt;&lt;table class="t1" border="1" width="200px"&gt; &lt;tr&gt; &lt;td width="50%"&gt;边框分离&lt;/td&gt; &lt;td width="50%"&gt;边框分离&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;br/&gt;&lt;br/&gt;&lt;table class="t2" border="1" width="200px"&gt; &lt;tr&gt; &lt;td width="50%"&gt;边框合并&lt;/td&gt; &lt;td width="50%"&gt;边框合并&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 预览]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript算法题（1）—— Return Largest Numbers in Arrays]]></title>
      <url>%2F2017%2F04%2F25%2FJavaScript%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94Return%20Largest%20Numbers%20in%20Arrays%2F</url>
      <content type="text"><![CDATA[Return an array consisting of the largest number from each provided sub-array. For simplicity, the provided array will contain exactly 4 sub-arrays. 1largestOfFour([[4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39], [1000, 1001, 857, 1]]); 1. Basic Code Solution12345678910111213function largestOfFour(arr) &#123; var results = []; for(var i = 0; i &lt; arr.length; i++)&#123; var largestNumber = 0; for(var j = 0; j &lt; arr[i].length; j++)&#123; if(arr[i][j] &gt; largestNumber) &#123; largestNumber = arr[i][j]; &#125; &#125; results[i] = largestNumber; &#125; return results;&#125; 算法说明： 创建results变量存储返回的结果数组； 创建一个外部循还遍历外层数组； 创建内层循还遍历每一个内层数组，寻找最大值，存储在变量largestNumber中； 将每一个内层数组中的最大值保存在results中的相应位置； 返回结果数组。 2. Intermediate Code Solution1234567function largestOfFour(arr) &#123; return arr.map(function(group)&#123; return group.reduce(function(prev, current) &#123; return (current &gt; prev) ? current:prev; &#125;,0); &#125;);&#125; Array.prototype.map() Array.prototype.reduce() Ternary Operators(三元运算) 3. Advanced Code Solution123function largestOfFour(arr) &#123; return arr.map(Function.apply.bind(Math.max, null));&#125; Function.prototype.apply() Function.prototype.bind()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS sprites原理]]></title>
      <url>%2F2017%2F04%2F24%2FCSS%20sprites%E5%8E%9F%E7%90%86%2F</url>
      <content type="text"><![CDATA[解释CSS sprites原理及优缺点。 CSS sprites其实就是把网页中一些背景图片整合到一张图片中，再利用CSS的background-image，background-repeat，background-position的组合进行背景定位，background-position可以用数字精确的定位出背景图片的位置。 优点： 减少网页的http请求。 减少图片的字节。 解决了网页设计师在图片命名上的困扰，只需对一张集合的图片上命名就可以了，不需要对每一个小元素进行命名，从而提高了网页的制作效率。 更换风格方便，只需要在一张或少张图片上修改图片的颜色或样式，整个网页的风格就可以改变。维护起来更加方便。 缺点： 在宽屏，高分辨率的屏幕下的自适应页面，图片如果不够宽，很容易出现背景断裂。 CSS sprites在开发的时候，要通过photoshop或其他工具测量计算每一个背景单元的精确位置。 在维护的时候比较麻烦，如果页面背景有少许改动，一般就要改这张合并的图片。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何解决 “Another git process seems to be running in this repository”]]></title>
      <url>%2F2017%2F04%2F23%2FHow%20to%20fix%20error%20%E2%80%9CAnother%20git%20process%20seems%20to%20be%20running%20in%20this%20repository%E2%80%9D%2F</url>
      <content type="text"><![CDATA[解决 git 推送中 “Another git process seems to be running in this repository” 问题。 错误： git bash使用命令行git commit提交修改时，还未提交成功，就点了关闭按钮。再次提交时，出现了如下错误。 意思是说，当前已有一个编辑器打开了“git commit”指令，请关闭所有git相关的进程重试，否则，请手动删除那个文件。 解决办法： 根据我们所了解到的，windows对于进程的同步互斥管理，是有资源上锁机制的。猜测这里肯定是有进程对某资源进行了加锁，但是由于进程突然崩溃，未来得及解锁，导致其他进程访问不了。进入工作区目录下的隐藏文件夹.git中，可以看到有index.lock文件，只需要删除此文件，就可解决问题。 使用如下命令删除index.lock文件： 1rm .git/index.lock]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS浮动]]></title>
      <url>%2F2017%2F04%2F20%2FCSS%E6%B5%AE%E5%8A%A8%2F</url>
      <content type="text"><![CDATA[介绍CSS浮动，浮动对父级元素和布局的影响，以及清除浮动的方法。 1. CSS浮动浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。 当把框 1 向右浮动时，它脱离文档流并且向右移动，直到它的右边缘碰到包含框的右边缘： 当框 1 向左浮动时，它脱离文档流并且向左移动，直到它的左边缘碰到包含框的左边缘。因为它不再处于文档流中，所以它不占据空间，实际上覆盖住了框 2，使框 2 从视图中消失。 如果把所有三个框都向左移动，那么框 1 向左浮动直到碰到包含框，另外两个框向左浮动直到碰到前一个浮动框。 如果包含框太窄，无法容纳水平排列的三个浮动元素，那么其它浮动块向下移动，直到有足够的空间。如果浮动元素的高度不同，那么当它们向下移动时可能被其它浮动元素“卡住”： 2. 浮动的影响2.1 浮动对父级元素的影响父级元素出现高度坍塌的问题。 解析：当没有为父元素设置高度时，父级元素的高度是由子元素的高度撑开的，当子元素浮动之后，就会脱离文档流，相当于是不存在于父级元素中，那么父级元素的高度就会塌陷为“0”。 2.2 浮动对布局的影响1.浮动能实现多个块元素处于同一行；2.子级浮动会使父级出现高度塌陷问题；3.浮动元素会对后面的兄弟级元素造成影响。 3. 清除浮动正是因为浮动的这种特性，导致本属于普通流中的元素浮动之后，包含框中由于不存在其他普通流元素了，也就表现出高度为0（高度塌陷）。在实际布局中，往往这并不是我们所希望的，所以需要清除浮动，使其包含框表现出正常的高度。 3.1 使用空标签清浮动12345&lt;div&gt; &lt;div style="float:left;"&gt;&lt;/div&gt; &lt;div style="float:left;"&gt;&lt;/div&gt; &lt;div style="clear:both;"&gt;&lt;/div&gt; &lt;/div&gt; 优点：通俗易懂，容易掌握缺点：增加无意义的空标签，后期维护不方便，不推荐使用。 3.2 使用br标签清浮动12345&lt;div&gt; &lt;div style="float:left;"&gt;&lt;/div&gt; &lt;div style="float:left;"&gt;&lt;/div&gt; &lt;br clear="all" /&gt; &lt;/div&gt; 优点：比空标签方式语义稍强，代码量较少。缺点：同样有违结构与表现的分离，不推荐使用。 3.3 父级div定义 overflow: hidden通过设置父元素overflow值设置为hidden；在IE6中还需要触发 hasLayout ，例如 zoom：1； 1234&lt;div style="overflow:hidden; *zoom:1;"&gt; &lt;div style="float:left;"&gt;&lt;/div&gt; &lt;div style="float:left;"&gt;&lt;/div&gt; &lt;/div&gt; 优点：不存在结构和语义化问题，代码量极少。缺点：无法显示溢出部分，不推荐使用。 3.4 让父级发生浮动优点：不存在结构和语义化问题，代码量极少。缺点：使得与父元素相邻的元素的布局会受到影响，不可能一直浮动到body，不推荐使用。 3.5 利用after伪元素清浮动1234&lt;div class＝"clearfix"&gt; &lt;div style="float:right;"&gt;&lt;/div&gt; &lt;div style="float:left;"&gt;&lt;/div&gt;&lt;/div&gt; 12345678.clearfix &#123;*zoom:1;&#125;.clearfix:after &#123; content:'.'; display:block; height:0px; clear:both; visibility: hidden; &#125; 1.content:&quot;.&quot;; 生成内容作为最后一个元素2.display:block; 使生成的元素以块级元素显示，占满剩余空间;3.height:0px; 避免生成内容破坏原有布局的高度。4.visibility:hidden; 使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互; 优点：结构和语义化完全正确，代码量居中。缺点：复用方式不当会造成代码量增加。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[position定位属性]]></title>
      <url>%2F2017%2F04%2F20%2Fposition%E5%AE%9A%E4%BD%8D%E5%B1%9E%E6%80%A7%2F</url>
      <content type="text"><![CDATA[介绍position定位属性，绝对/固定定位的定位原理以及绝对/相对定位的区别。 1. position定位属性有哪些1position: static | relative | absolute | fixed | inherit static：默认值，没有定位； relative：生成相对定位元素，相对于其正常位置进行定位； absolute：生成绝对定位元素，相对于static以外的第一个父元素进行定位； fixed：生成固定定位的元素，相对于浏览器窗口进行定位； inherit：规定从父元素继承position属性的值。 2. 绝对/固定定位的定位原理 绝对定位：absolute 相对于设置了除static定位以外的第一个父元素进行定位； 固定定位：fixed相对于浏览器窗口进行定位 解析： 如果父级（无限）没有设定position属性，那么当前的absolute则结合top，right，left，bottom属性以浏览器左上角为原始点进行定位。 如果父级（无限）设定position属性，且属性值为relative、absolute、fixed，那么当前的absolute则结合top，right，left，bottom属性以父级（最近）的左上角为原始点进行定位。 3. 绝对/相对定位的区别​ 主要从二者是否脱离文档流、是否会重叠、定位的参照物方面进行比较： 相对定位不会脱离文档流，绝对定位脱离文档流； 绝对定位的元素相互层叠，相对定位的元素不会； 绝对定位的元素相对于static以外的第一个父元素进行定位，相对定位相对于其正常位置进行定位。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[a标签伪类的书写顺序及原因]]></title>
      <url>%2F2017%2F04%2F19%2Fa%E6%A0%87%E7%AD%BE%E4%BC%AA%E7%B1%BB%E7%9A%84%E4%B9%A6%E5%86%99%E9%A1%BA%E5%BA%8F%E5%8F%8A%E5%8E%9F%E5%9B%A0%2F</url>
      <content type="text"><![CDATA[a 标签书写顺序：:link, :visited, :hover, :active; 简记：lvha。 链接未进行访问时，显示 link 样式，也就是链接的默认样式； 当访问过了该链接，显示 visited 样式，由于两种选择器的优先级相等，必须让 visited 样式覆盖 link 样式，因此要先写 link 样式； 当鼠标移动到链接上时，可能是未访问也可能是已经访问， hover 样式要能够覆盖另外两种样式，因此 hover 要放在 visited 的后面； 当鼠标按下时，鼠标处于 a 标签之上（ hover 效果也处于激活状态），为了能够区分悬停和按下，需要让 active 样式覆盖 hover 样式，即 active 的样式放置在最后。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[七种隐藏元素的方法]]></title>
      <url>%2F2017%2F04%2F19%2F%E4%B8%83%E7%A7%8D%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[列举七种隐藏元素的方法。 visiable:hidden;这个属性只是简单的隐藏某个元素，但是元素占用文档空间。 opacity:0;CSS3属性，可以使一个元素完全透明，与visiable:hidden效果相同。与visiable相比，它可以设置transition和animate。 position:absolute;使元素脱离文档流，处于普通文档之上，给它设置一个很大的left负值定位，使元素定位在可见区域之外。 display:none;元素变得不可见，与visiable:hidden不同的是不会占用文档空间。 transform:scale(0);将一个元素设置为无限小，这个元素将不可见，但是元素占用的空间仍然保留。 height:0;overflow:hidden;将元素的高度设置为0，只要元素没有可见的边框，就可以使元素消失。 filter:blur(0);将元素的模糊度设为0，从而使这个元素“消失”在页面中。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[事件绑定]]></title>
      <url>%2F2017%2F04%2F11%2F%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%2F</url>
      <content type="text"><![CDATA[如何在选定的元素上绑定一个或多个事件处理函数; 绑定鼠标滚轮事件; 如何判断鼠标滚轮方向; 绑定键盘方向键. 1. 如何在选定的元素上绑定一个或多个事件处理函数？语法：on(events[,selector][,data],handler(eventObject)) 描述： events: 一个或多空格分隔的事件类型，例如 click keydown。 selector: 一个选择器字符串，用于过滤出被选中的元素中能触发事件的后代元素，如果为 null，那么被选中的元素总是能触发事件。 data: 事件触发时，要传递给处理函数的 event.data。 handler(eventObject): 事件触发时，执行的函数。 2. 绑定鼠标滚轮事件 包括IE6浏览器在内都使用 mouseWheel, 而只有火狐浏览器使用 DOMMouseScroll; $(document).on(&quot;mouseWheel DOMMouseScroll&quot;,handler). 3. 如何判断鼠标滚轮方向 其他浏览器通过 wheeldalta 属性来判断，但是火狐浏览器没有这个属性，可以通过 detail 属性判断； 开发中发现每次向下滚动时，wheeldalta 都是-120，但是detail确是3，火狐浏览器方向判断的数值正负与其他浏览器是相反的。 4. 绑定键盘方向键 IE：只有keyCode属性; Firefox：有which和charCode属性; Opera：有keyCode和which属性; 但是 jQuery 已经解决了这个兼容问题，通过.witch属性和.keyCode属性来确定按下了哪个键： arrow up：37 arrow left：38 arrow right：39 arrow down：40 12345678$(window).on("keydown",function(e)&#123; var keyCode = e.keyCode; if(keyCode == 37 || keyCode == 38)&#123; ... &#125;else if(keyCode == 39 || keyCode == 40)&#123; ... &#125;&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何解决failed to push some refs to git]]></title>
      <url>%2F2017%2F04%2F06%2F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3failed%20to%20push%20some%20refs%20to%20git%2F</url>
      <content type="text"><![CDATA[由于Github中的README.md文件不在本地代码目录中，导致执行git push -u origin master 时出现错误。 1234git initgit commit -m "first commit"git remote add origin your Github repositorygit push -u origin master 1. 在使用git 对源代码进行push到Github时出现如下错误信息：error: failed to push some refs to 2. 出现错误的主要原因是Github中的README.md文件不在本地代码目录中.可以通过如下命令进行代码合并[ 注：pull=fetch+merge] 1$ git pull --rebase origin master 3. 执行上面代码后可以看到本地代码库中多了README.md文件.此时再执行以下语句即可完成代码上传到Github. 1git push -u origin master]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一个页面从输入URL到页面显示完成的过程]]></title>
      <url>%2F2017%2F04%2F02%2F%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA%E5%AE%8C%E6%88%90%E7%9A%84%E8%BF%87%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[一个页面从输入url到页面加载显示完成，这个过程都发生了什么？ 一个页面从输入url到页面加载显示完成的过程，大致分为以下几步： 浏览器地址栏输入url； 浏览器会先查看浏览器缓存–系统缓存–路由缓存，如有存在缓存，就直接显示。如果没有，接着第三步 DNS解析、查找该域名对应的IP地址、重定向（301）、发出第二个GET请求； 进行HTTP协议会话； 客户端发送报头（请求报头）； 服务器回馈报头（响应报头）； html文档开始下载； 文档树建立，根据标记请求所需指定MIME类型的文件； 文件显示。 浏览器这边做的工作大致分为以下几步： 加载：根据请求的URL进行域名解析，向服务器发起请求，接收文件（HTML, JS, CSS, Image等）。 解析：对加载到的资源（HTML, JS, CSS, Image等）进行语法解析，建立响应的内部数据结构（比如HTML的DOM树，JS的（对象）属性表，CSS的样式规则等）。 ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo个人博客后期部署]]></title>
      <url>%2F2017%2F03%2F30%2FHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%90%8E%E6%9C%9F%E9%83%A8%E7%BD%B2%2F</url>
      <content type="text"><![CDATA[Hexo+Github个人博客后期部署的另一种方法。 之前部署博客都是采用下面的方式： 12345$ hexo new(n) xxx //写文章$ hexo clean //清除缓存$ hexo generate(g) //把文章生成页面$ hexo server(s) //启动本地服务调试$ hexo deploy(d) //部署到github 可与hexo g合并为 hexo d -g 这种方式的commit记录： 另一种方式： 当我新增文章或者修改内容以后，先hexo generate生成静态页面，然后我每一次只需要将public文件夹git push到我的github上对应的博客仓库里即可。不需要再清除缓存。 可以通过git status查看文件状态，通过git commit -m &quot;message&quot;提交记录。 这种方式的commit记录： 是不是看起来清晰很多呢？嘻嘻 ^_^]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Flex布局]]></title>
      <url>%2F2017%2F03%2F29%2FFlex%E5%B8%83%E5%B1%80%2F</url>
      <content type="text"><![CDATA[Flex布局——W3C于2009年提出的一种新的布局方案。相比于传统的布局方式，即基于盒模型，依赖display + position + float 属性，Flex布局可以简便、完整、响应式地完成各种页面布局，而且目前已经得到了所有浏览器的支持。 1. Flex容器采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 2. 容器的属性共有6个容器属性： flex-direction flex-wrap flex-flow justify-content align-items align-content 2.1 flex-direction属性flex-direction属性决定主轴的方向（即项目的排列方向）。 flex-direction:row | row-reverse | column | column-reverse; 它可能有4个值: row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 2.2 flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 flex-wrap: nowrap | wrap | wrap-reverse; 它可能有3个值: nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 2.3 flex-flow属性flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; 2.4 justify-content属性justify-content属性定义了项目在主轴上的对齐方式。 justify-content: flex-start | flex-end | center | space-between | space-around; 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 2.5 align-items属性align-items属性定义项目在交叉轴上如何对齐。 align-items: flex-start | flex-end | center | baseline | stretch; 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 2.6 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 align-content: flex-start | flex-end | center | space-between | space-around | stretch; 该属性可能取6个值。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 以上。 3. 项目的属性以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flex align-self 3.1 order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 order: &lt;integer&gt;; 3.2 flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 flex-grow: &lt;number&gt;; /* default 0 */ 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 3.3 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 flex-shrink: &lt;number&gt;; /* default 1 */ 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 3.4 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 flex-basis: &lt;length&gt; | auto; /* default auto */ 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 3.5 flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 flex: none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ] 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 3.6 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 align-self: auto | flex-start | flex-end | center | baseline | stretch; 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 4. Flex实现水平、垂直居中4.1 单个元素水平居中1234567891011121314/* CSS 代码 */.box &#123; display: flex; justify-content: center; background: #0099cc;&#125;h1 &#123; color:#fff;&#125;//HTML 代码&lt;div class="box"&gt; &lt;h1&gt;单个元素水平居中&lt;/h1&gt;&lt;/div&gt; 效果预览 ​ 我们只需要给h1标签的父元素添加两个属性就可以了，justify-content其作用就是 让class类为box的div盒子居中。盒子居中了，盒子里面的元素就自然居中了，他的好处就是不需要对需居中的元素（h1）设置任何样式，如果：width，margin。 4.2 多个h1元素水平居中1234567891011121314151617181920// HTML 代码&lt;div class="box"&gt; &lt;h1&gt;多个h1元素水平居中&lt;/h1&gt; &lt;h1&gt;多个h1元素水平居中&lt;/h1&gt; &lt;h1&gt;多个h1元素水平居中&lt;/h1&gt;&lt;/div&gt;/* CSS代码 */.box&#123; display: flex; justify-content: center; width: 100%; background: #0099cc&#125;h1&#123; font-size: 1rem; padding: 1rem; border: 1px dashed #FFF; color: #fff;&#125; 效果预览 ​ 在Flex有两个东西，一个是Flex容器（子项目父元素），另一个是子项目（Flex容器子元素）。如果不给.box添加样式， 一个h1标签占一行，也就是页面会显示三行文字 “多个h1元素水平居中”。如果我们给.box添加了display: flex;那么三个h1标签就妥妥地在一行里排列了，相当于浮动，只不过他不会因为超出了.box的宽度而换行，他总是会在一行内显示。 4.3 单个h1标签垂直居中12345678910111213141516171819// HTML 代码&lt;div class="box"&gt; &lt;h1&gt;单个h1标签垂直居中&lt;/h1&gt;&lt;/div&gt;/* CSS代码 */.box&#123; display: flex; width: 980px; height: 30rem; align-items:center; background: #0099cc&#125;h1&#123; font-size: 1rem; padding: 1rem; border: 1px dashed #FFF; color: #FFF&#125; 效果预览 4.4 多个h1标签垂直居中123456789101112131415161718192021// HTML 代码&lt;div class="box"&gt; &lt;h1&gt;单个h1标签垂直居中&lt;/h1&gt; &lt;h1&gt;单个h1标签垂直居中&lt;/h1&gt; &lt;h1&gt;单个h1标签垂直居中&lt;/h1&gt;&lt;/div&gt;/* CSS代码 */.box&#123; display: flex; width: 980px; height: 30rem; align-items:center; background: #0099cc&#125;h1&#123; font-size: 1rem; padding: 1rem; border: 1px dashed #FFF; color: #FFF&#125; 效果预览 4.5 多个h1标签水平垂直居中12345678910111213141516171819202122232425262728// HTML 代码&lt;div class="box"&gt; &lt;h1&gt;多个h1标签水平垂直居中&lt;/h1&gt; &lt;h1&gt;多个h1标签水平垂直居中&lt;/h1&gt; &lt;h1&gt;多个h1标签水平垂直居中&lt;/h1&gt; &lt;h1&gt;多个h1标签水平垂直居中&lt;/h1&gt;&lt;/div&gt;/* CSS代码 */body&#123;display: flex;justify-content:center&#125;.box&#123; display: flex; width: 980px; height: 30rem; background: #0099cc; justify-content:center; flex-direction:column; align-items:center;&#125;h1&#123; display: flex; justify-content:center; font-size: 1rem; padding: 1rem; border: 1px dashed #FFF; color: #FFF; width: 28rem；&#125; 效果预览 ​ 为了让h1里的文字居中，我们给h1添加了display:flex; 以及justify-content:center，同样的为了让h1在.box里垂直居中，我们给.box也加上 display:flex;以及justify-content:center属性。而.box里的align-items:center就 是让h1水平居中的。这个属性的作用是：定义项目在交叉轴上的对齐方式。由于我们使用了 flex-direction:column;所以垂直方向作为主轴，交叉轴自然就是水平方向了。为了让.box也水平居中，我们同时也定义了body{display:flex;justify- content:center}。 学习链接： Flex布局教程：语法篇 Flex布局教程：实例篇]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[页面重绘（repaint）和页面回流（reflow）]]></title>
      <url>%2F2017%2F03%2F14%2F%E9%A1%B5%E9%9D%A2%E9%87%8D%E7%BB%98%E5%92%8C%E9%A1%B5%E9%9D%A2%E5%9B%9E%E6%B5%81%2F</url>
      <content type="text"><![CDATA[如果你的HTML变得很大很复杂，那么影响你javaScript性能的可能并不是javaScript代码的复杂度，而是页面的回流和重绘。 1. 页面的渲染过程1.1 解析HTML文件，创建DOM树浏览器将获取到的html代码解析成1个DOM树，html中的每个tag都是DOM树中的节点，根节点是document对象（即标签)。DOM树包含了所有的html标签，包括display: none 的元素，还有js动态添加的元素等。 1.2 解析CSS浏览器把所有样式（主要包括css和浏览器的样式设置）解析成样式结构体，在解析中去掉不能识别的样式，比如IE会去掉-moz开头的样式，而firefox会去掉_开头的样式。 1.3 将CSS和DOM合并，构建渲染树（render tree） render tree和dom tree类似，但其实区别很大，render tree能识别样式，render tree中的每个节点都有自己的样式，而且render tree忽略诸如head、diaplay: none的元素，因为这些样式不会影响页面的呈现。 注意：visiability: hidden隐藏的元素还是会包含，因为它会影响布局，会占有空间。 1.4 布局和绘制一旦render tree构建完毕后，浏览器就可以根据render tree来绘制页面了。浏览器在绘制页面的过程中不断的进行着重绘和回流。 2. 重绘和回流2.1 重绘和回流重绘(repaint)：当render tree中的一些元素需要更新属性，单这些属性只会影响元素的外观，风格，而不会影响到元素的布局，此类的页面渲染叫作页面重绘。 回流(reflow)：当render tree中的一部分（或全部）因为元素的规模尺寸，布局，隐藏等改变而引起的页面重新渲染。 可以看出，回流必将引起重绘，而重绘不一定会引起回流。 2.2 引发回流的范例当页面布局和几何属性改变时就需要回流。下述情况会发生浏览器回流： DOM树发生变化——如：增加一个元素或删除一个元素（元素为可见元素）； 通过style控制元素的位置变化——典型的碰壁反弹； 元素尺寸的改变——盒模型的每种尺寸均算在其内； 内容改变引发的尺寸改变——如：文本文本改变或者图片大小改变而引起的计算值宽度和高度改变； 浏览器窗口尺寸改变——resize事件发生时。 2.3 改善由于dom操作产生的回流减少回流、重绘其实就是需要减少对render tree的操作，并减少对一些style信息的请求，尽量利用好浏览器的优化策略。具体方法有： （1）不要一个一个改变元素的样式属性，直接改变className，如果动态改变样式，则使用cssText。 如下面代码： 1234567891011//不好的写法var left = 1;var top = 1;el.style.left = left + "px";el.style.right = right + "px";//比较好的写法el.className += "className1";//动态改变样式，比较好的写法el.style.cssText += ";left:" + left + "px; top:" + top + "px;"; （2）让要操作的元素进行“离线处理”，处理完后一起更新。这里所谓的”离线处理”即让元素不存在于render tree中，比如： 使用DocumentFragment进行缓存操作,引发一次回流和重绘； 这个主要用于添加元素的时候，就是先把所有要添加到元素添加到1个div中(这个div也是新加的)，最后才把这个div append到body中。 使用display:none技术，只引发两次回流和重绘； 先display:none 隐藏元素，然后对该元素进行所有的操作，最后再显示该元素。因对display:none的元素进行操作不会引起回流、重绘。所以只要操作只会有2次回流。 使用cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘。 （3）不要经常访问会引起浏览器flush队列的属性，如果你确实要访问，利用缓存。 12345678910111213141516//不好的写法for(循环) &#123; el.style.left = el.offsetLeft + 5 + "px"; el.style.top = el.offsetTop + 5 + "px"; &#125;// 比较好的写法var left = el.offsetLeft, top = el.offsetTop, s = el.style;for(循环) &#123; left += 10; top += 10; s.left = left + "px"; s.top = top + "px"; &#125; （4）让元素脱离动画流，减少回流的Render Tree的规模。 ​ 假设block1是position: absolute的元素，block2是position: relative的元素。当使用jquery的animate()方法移动元素来展示一些动画效果时： $(&quot;#block1&quot;).animate({left:50}); ​ block1移动，会影响到它父元素下的所有子元素。因为在移动过程中，所有子元素需要判断block1的z-index是否在自己的上面，如果是在自己的上面，则需要重绘，这里不会引起回流。 $(&quot;#block2&quot;).animate({marginLeft:50}); ​ block2是相对定位的元素，影响的元素与block1一样，但是因为block2非绝对定位，而且改变的是marginLeft属性，所以这里每次改变不但会重绘，还会引起父元素及其下元素的回流。 ​ 所以，动画效果应用到position属性为absolute或fixed的元素上，它们不影响其他元素的布局，所它他们只会导致重新绘制，而不是一个完整回流。这样消耗会更低。 参考链接： 回流与重绘：CSS性能让JavaScript变慢？ 高性能WEB开发(8) - 页面呈现、重绘、回流]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Canvas实现放大镜效果]]></title>
      <url>%2F2017%2F03%2F10%2FCanvas%E5%AE%9E%E7%8E%B0%E6%94%BE%E5%A4%A7%E9%95%9C%E6%95%88%E6%9E%9C%2F</url>
      <content type="text"><![CDATA[我们在购物时，经常会看到这样的效果：当鼠标划过商品时，会在展示图旁边出现一个商品局部放大图，这就是放大镜效果。这个小效果可以由HTML5的canvas实现，主要依靠canvas中的drawImage()函数，可以初步认识canvas。让我们快点开始吧。 效果图： 1. 实验原理一个canvas绘制好一张图片，当鼠标移到canvas上边的时候出现一个透明框，同时另一个canvas(copycanvas)开始绘制透明框部分的图像，利用drawImage()可修改绘制时的大小以实现放大效果。 需要注意的细节： 透明框不能移除canvas； 鼠标移入、移出canvas时，copycanvas能对应的显示、隐藏。 2. 需要用到的知识点介绍2.1 drawImage()函数此函数为canvas绘制图像方法，即将图像绘制到canvas中，并将图像像素映射为canvas坐标系统的一个单元。 drawImage()可以接受一下 3 套参数： drawImage(imagedata, dx, dy);此方法会将整幅图像绘制到 canvas的指定位置上，dx ，dy分别指目标 canvas 开始绘制点的 x , y坐标。 drawImage(imagedata, dx, dy , dw, dh);此套参数中新增的2个参数dw,dh分别代表绘制时指定的宽和高（也因此实现缩放的效果）。 drawImage(imagedata, sx, sy, sw, sh, dx, dy, dw, dh);此套参数中又新增了4个参数sx, sy, sw, sh,分别代表被绘制图像开始绘制点的 x, y坐标，以及被绘制部分的宽和高。 2.2 Dom Event 对象当然完成放大镜效果，最终达到和商品展示的放大效果一致，光是 canvas 的图像绘制还是不够的。当我们在商品展示图上移动鼠标能及时看到效果，这就是需要 Dom Event 对象的支持，介绍几个项目中涉及到的对象： onmouseover 鼠标移动到某元素之上触发事件 onmousemove 鼠标在某元素之上移动时触发事件 2.3 Dom Element 对象当我们想要控制透明选择框不移出canvas，就需要时刻计算透明选择框和canvas的边距关系，这便涉及到接下来我要介绍的几个 Dom Element 对象： offsetLeft 返回元素水平偏移量(从上到下开始计算) offsetTop 返回元素垂直偏移量(从左到右开始计算) 3. 步骤3.1 页面设计123456&lt;body&gt; &lt;canvas id="canvas" width="430" height="430"&gt;&lt;/canvas&gt; &lt;canvas id="copycanvas" width="300" height="300"&gt;&lt;/canvas&gt; &lt;div id="square"&gt;&lt;/div&gt; &lt;script src="main.js"&gt;&lt;/script&gt;&lt;/body&gt; 3.2 简单的样式设计123456789101112131415#copycanvas &#123; border: 1px solid #000; display: none;&#125;#square &#123; width: 90px; height: 90px; background-color: #cc3; border: 1px solid #f00; opacity: 0.5; position: absolute; z-index: 999; display: none; cursor: crosshair;&#125; 3.3 javascript部分3.3.1 定义所需变量和共有对象,创建图像对象，并加载123456789101112131415161718var canvas = document.getElementById('canvas'), //获取canvas对象 context = canvas.getContext('2d'), //获取上下文 copycanvas = document.getElementById('copycanvas'), //获取copycanvas copycontext = copycanvas.getContext('2d'), square = document.getElementById('square'), //获取透明框 squaredata = &#123;&#125;, //用来保存选择框数据 box = canvas.getBoundingClientRect(); //getBoundingClientRect方法可以获取元素上、下、左、右分别相对浏览器的坐标位置//创建图像对象，并加载image = new Image();image.src = "1.jpg";image.onload = function()&#123; context.drawImage(image,0,0,canvas.width,canvas.height);&#125; 3.3.2 触发事件1234567891011121314151617181920canvas.onmouseover = function(e)&#123; var x = e.clientX, //获取鼠标实时坐标 y = e.clientY; createSquare(x,y); //保存透明选择框属性&#125;window.onmousemove = function(e)&#123; var x = e.clientX, y = e.clientY; //判断鼠标是否移出canvas if(x &gt;= canvas.offsetLeft &amp;&amp; x &lt;= canvas.offsetLeft + canvas.width &amp;&amp; y &gt;= canvas.offsetTop &amp;&amp; y &lt;= canvas.offsetTop + canvas.height)&#123; createSquare(x,y); &#125;else&#123; hideSquare(); hideCanvas(); &#125;&#125; 3.3.3 显示、隐藏选择框和copycanvas123456789101112function showSquare()&#123; square.style.display = 'block';&#125;function hideSquare()&#123; square.style.display = 'none';&#125;function showCanvas()&#123; copycanvas.style.display = "inline";&#125;function hideCanvas()&#123; copycanvas.style.display = "none";&#125; 3.3.4 移动鼠标同时实时移动选择框12345678910111213141516171819function createSquare(x,y)&#123; //控制选择框不移动出canvas x = x - 45 &lt; canvas.offsetLeft ? canvas.offsetLeft:x - 45; y = y - 45 &lt; canvas.offsetTop ? canvas.offsetTop:y - 45; x = x + 90 &lt; box.right ? x:box.right - 90; y = y + 90 &lt; box.bottom ? y:box.bottom - 90; squaredata.left = x; squaredata.top = y; moveSquare(x,y);&#125;function moveSquare(x,y)&#123; square.style.left = x + "px"; square.style.top = y + "px"; showCanvas(); showSquare(); copy();&#125; 3.3.5 绘制canvas到copycanvas实现放大效果12345678910111213function copy()&#123; copycontext.drawImage( canvas, squaredata.left - box.left, squaredata.top - box.top, 90, 90, 0, 0, copycanvas.width, copycanvas.height );&#125; 到此，便完全实现了放大镜效果。 4. 总结网上也有各种版本的放大镜效果插件，比如jQuery插件。它的原理是，准备了一大一小且内容相同的两张图，然后通过设置大图的position: absolute，控制left、right属性，以及overflow: hidden，以此来模拟放大效果。显而易见，这样做无意义的增加了请求次数，浪费流量；而且并没有真正的实现图片的局部放大效果。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript中的call()和apply()方法]]></title>
      <url>%2F2017%2F03%2F04%2F2017-03-04-JavaScript%E4%B8%AD%E7%9A%84call()%20%E5%92%8Capply()%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[JavaScript中的call()和apply()都是用于调用当前函数functionObject，并可同时使用指定对象thisObj作为本次执行时functionObject函数内部的this指针引用。 它们都输属于Function对象，所有主流浏览器均支持。 1. call()和apply()的定义1.1 call()方法定义：调用一个对象的一个方法，以另一个对象替换当前对象。 语法：functionObject.call( [ thisObj [, arg1 [, arg2 [, args...]]]] ) 参数： 参数 描述 thisObj 可选/Object类型，指定执行functionObject函数时，函数内部this指针引用的对象。 arg1 可选/任意类型，调用functionObject函数时传入的第1个参数。 arg2 可选/任意类型，调用functionObject函数时传入的第2个参数。 args 可选/任意类型，调用functionObject函数时传入的更多参数，可以有多个。 1.2 apply()方法定义：应用一个对象的一个方法，用另一个对象替换当前对象。 语法：functionObject.apply( [ thisObj [, argsArray ]] ) 参数： 参数 描述 thisObj 可选/Object类型，指定执行functionObject函数时，函数内部this指针引用的对象。 argsArray 可选/Array或arguments对象，调用functionObject时传入的参数数组或arguments对象。 1.3 call()和apply()的异同相同点： 都可以用来代替另一个对象调用一个方法，将一个函数的对象上下文从初始的上下文改变为由thisObj指定的新对象。 不同点： call():则是直接的参数列表，主要用在js对象各方法互相调用的时候，使当前this实例指针保持一致,或在特殊情况下需要改变this指针。如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。 apply()：最多只能有两个参数———新this对象和一个数组argsArray。如果给该方法传递多个参数，则把参数都写进这个数组里面，当然，即使只有一个参数，也要写进数组里面。如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。如果没有提供argsArray 和thisObj任何一个参数，那么Global对象将被用作thisObj，并且无法被传递任何参数。 总结： call()和apply()都可以用来代替另一个对象调用一个方法，将一个函数的对象上下文从初始的上下文改变为由thisObj指定的新对象。 call()函数是将FunctionObject的参数一个个分别传入，如functionObject.call(thisObj,arg1,arg2,arg3)； apply()函数是将FunctionObject对象的参数以一个数组或arguments对象的形式整体传入,如functionObject.apply(func1,[arg1,arg2,arg3])。 2. call()和apply()实例2.1 实例一12345678910function add(a, b) &#123; alert(a + b);&#125;function sub(a, b) &#123; alert(a - b);&#125;add.call(sub, 3,1);//add.apply(sub, [3,1]); 说明： 例子中用add来替换sub，add.call(sub,3,1) == add(3,1)，所以运行结果为：4; 需要注意的是，这里直接用了函数名sub，而不是sub(),因为在js中的函数其实是对象，函数名是对Function 对象的引用。 2.1 实例二12345678910111213141516function Animal(name) &#123; this.name = name; this.showName = function() &#123; alert(this.name); &#125;&#125;function Cat(name) &#123; this.name = "Cat";&#125;var animal = new Animal();var cat = new Cat();animal.showName.call(cat,",")//animal.showName.apply(cat,[]); 说明 通过call或apply方法，将原本属于Animal对象的showName()方法交给对象cat来使用了。因此输入结果为&quot;Cat&quot;。 2.3 实例三（实现继承）1234567891011121314function Animal(name) &#123; this.name = name; this.showName = function() &#123; alert(this.name); &#125; &#125; function Cat(name) &#123; Animal.call(this, name); //Animal.apply(this, [name]);&#125; var cat = new Cat("Black Cat"); cat.showName(); 说明： Animal.call(this, name) 的意思就是使用 Animal对象代替this对象，那么Cat对象就能够直接调用Animal的方法以及属性了。 2.4 实例四（多重继承）12345678910111213141516171819202122function Class10() &#123; this.showSub = function(a,b) &#123; alert(a-b); &#125;&#125;function Class11() &#123; this.showAdd = function(a,b) &#123; alert(a+b); &#125;&#125;function Class2() &#123; Class10.call(this); Class11.call(this); //Class10.apply(this); //Class11.apply(this);&#125;var c2=new Class2();c2.showSub(3,1);c2.showAdd(3,1); //使用两个 call 就实现多重继承 3. apply()的其他妙用既然apply和call的用法差不多，那么为什么还同时存在呢？ ——这是因为apply所传的参数类型（数组）还有其他妙用。 3.1 Math.max可以实现得到数组中最大的一项因为Math.max参数不支持数组传递，但是它支持列表传递，即Math.max(param1,param2,param3…),所以可以根据apply的特点来解决 var max=Math.max.apply(null,array)，这样轻易的可以得到一个数组中最大的一项。(apply会将一个数组转换为一个参数接一个参数的传递给方法)。 注意：调用的时候第一个参数给了一个null，是因为没有对象去调用这个方法，只需要用这个方法帮助运算，得到返回的结果就行，所以直接传递了一个null过去。 3.2 Array.min 可以实现得到数组中最小的一项同样和max是一个思想 var min=Math.min.apply(null,array)。 3.3 Array.prototype.push 可以实现两个数组合并同样push方法没有提供push一个数组，但是它提供了push(param1,param,…paramN) 所以同样也可以通过apply来转换一下这个数组，即: 123var arr1=new Array("1","2","3"); var arr2=new Array("4","5","6"); Array.prototype.push.apply(arr1,arr2); 也可以这样理解，arr1调用了push方法，参数是通过apply将数组装换为参数列表的集合。 总结： 当目标函数只需要n个参数列表,而不接收一个数组的形式（[param1[,param2[,…[,paramN]]]]），可以通过apply的方式巧妙地解决这个问题。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript正则]]></title>
      <url>%2F2017%2F03%2F03%2F2017-03-03-JavaScript%E6%AD%A3%E5%88%99%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[正则表达式，又称规则表达式。简单讲就是一个用来处理字符串的规则，这里的“处理”一般包含匹配和捕获。 1. 初识正则1.1正则的匹配和捕获 匹配：判断一个字符串是否符合指定的规则，使用reg.test(str) 123var reg = /\d/; //包含一个0-9之间的数字console.log(reg.test('1')); //trueconsole.log(reg.test('我今年18岁')); //true,只要包含数字就返回true 捕获：获取字符串中符合指定的规则的内容，使用reg.exec(str) 123var reg = /\d/;console.log(reg.exec('1')); //["1", index: 0, input: "1"]console.log(reg.exec('我今年18岁')); //["1", index: 3, input: "我今年18岁"] 1.2 创建正则 字面量方式 1var reg = /\d/; 实例方式 1var reg = new RegExp('/\d/'); 2. 正则的组成2.1 元字符 具有特殊意义的元字符 \: 转义字符，转义后面字符所代表的含义 ^: 以某一个元字符开始 $: 以某一个元字符结束 .: 除了\n以外的任意字符 \n: 匹配一个换行符 1234567var reg = /^0.5$/; // 以0开头，以5结尾，中间可以是除了\n的任意字符console.log(reg.test('0.5')); // trueconsole.log(reg.test('0-5')); // truereg = /^0\.5$/; // 将"."转义,中间必须是"."console.log(reg.test('0.5')); // trueconsole.log(reg.test('0-5')); // false 代表出现次数的量词元字符 *：出现0到多次 +：出现1到多次 ?：出现0次或者1次 {n}：出现n次 {n,m}：出现n到m次 12var reg = /\d+/; //匹配0-9之间的数字最少一次console.log(reg.test('2015')); // true 2.2 修饰符 x|y：x或y中的一个 [xyz]：x或y或z中的一个 [^xyz]：除了xyz以外的任意一个字符 [a-z]：a-z之间的任何一个字符 [^a-z]：除了a-z之间的任何一个字符 \d：一个0~9之间的数字 \D：除了0~9之间的数字以外的任何字符 \b：一个边界符 \w：数字、字母、下划线中的任意一个字符 \s：匹配一个空白字符、空格 ()：分组，把一个大正则本身划分成几个小的正则，例如：var reg = /^(\d+)zhufeng(\d+)$/; 3. 元字符的应用在做元字符的应用前，有必要先了解下中括号和分组的使用。 3.1 []的规律 在中括号中出现的所有的字符都是代表本身的意思的字符（没有特殊含义） 123456var reg = /^[.]$/;console.log(reg.test('1')); // falseconsole.log(reg.test('.')); // truereg = /^[\w-]$/; // 数字、字母、下划线、- 中的一个console.log(reg.test('-')); // true 中括号不识别两位数 12var reg = /^[12]$/; // --&gt; 1或者2中的一个（符合[xyz]）var reg = /^[12-68]$/; // --&gt; 1、2-6中的一个、8 三个中的一个 3.2 ()的作用 改变x|y的默认的优先级 12var reg = /^18|19$/; // 18、19、181、189、119、819、1819这些都符合var reg = /^(18|19)$/; // 只能18或者19 3.3 应用 应用一：有效数字的正则 有效数字可以是正数、负数、零、小数，所以其特点为： “.”可以出现也可以不出现，一旦出现，后面必须跟着一位或多为数字； 最开始可能有“+/-”，也可以没有； 整数部分，一位数的情况可以是0-9中的一个，多位数的情况下不能以0开头； 1var reg = /^[+-]?(\d|([1-9]\d+))(\.\d+)?$/; 应用二：年龄介于18~65之间年龄介于18~65之间的数字可以是18-19、20-59、60-65。 1var reg = /^1[8-9]|[2-5]\d|6[0-5]$/; 应用三：简单的邮箱验证 1var reg = /^[\w.-]+@[0-9a-zA-Z]+(\.[a-zA-Z]&#123;2,4&#125;)&#123;1,2&#125;$/; 4. 两种方式创建正则的区别创建正则有两种方式：字面量方式、对象方式。 在字面量方式中，”//“之间包起来的所有的内容都是元字符，有的具有特殊的意义，大部分都是代表本身含义的普通元字符。 正则中的某一段内容是不固定的，那么我们用字面量的方式可能会这么写： 1234var name = 'iceman';var reg = /^\d+"+name+"\d+$/;console.log(reg.test('2015iceman2016')); // falseconsole.log(reg.test('2015"""nameeee"2016')); // true 为什么出现这样的结果？与我们的想法不一致。仔细一看，就会发现我们在第二条匹配的字符串中写了三个引号，name的后面再加了三个e。 因为在字面量方式创建的正则中，引号和单独出现的加号都被当成了普通的元字符。就会解析成匹配“一次或多次，破匹配e一次或多次，对于上面的这个需求，我们只能使用实例创建正则的方式： 123var name = 'iceman';var reg = new RegExp("^\\d+" + name + "\\d+$", "g");console.log(reg.test('2015iceman2016')); // true 所以总结字面量方式和实例方式创建正则的区别： 字面量方式中出现的一切都是元字符，不能进行变量值的拼接，而实例创建的方式可以； 字面量方式中直接写\d可以，而在实例中需要把它转义 \\d 5. 正则的捕获及其贪婪性和懒惰性5.1 懒惰性12var reg = /\d+/;var str = 'iceman2016learn2017'; reg默认有一个lastIndex字段，该字段是正则每一次捕获时，在字符串中开始查找的位置，默认的值是0。 第一次捕获： 123console.log(reg.lastIndex); // 0，第一次捕获的时候，从字符串索引0处开始查找var res = reg.exec(str);console.log(res); // ["2016", index: 6, input: "iceman2016learn2017"] 从代码的输出可知，正则捕获的内容格式：捕获到的内容是一个数组: 数组的第一项是当前大正则捕获的内容； 有一项是index：捕获内容在字符串中开始的索引位置； 有一项是input：捕获的原始字符串； 现在进行第二次捕获： 1234console.log(reg.lastIndex); // 0 说明第二次捕获的时候，也要从字符串索引0处开始查找// 第二次通过exec捕获的内容还是第一个"2016"res = reg.exec(str);console.log(res); //["2016", index: 6, input: "iceman2016learn2017"] 由上面的两次捕获可知，每次的捕获都是从字符串的索引0处开始查找的，这就是正则的懒惰性。 如何解决？ 在正则的末尾加一个修饰“g”（全局匹配），类似g这样的修饰符还有两个：i、m，这三者的作用是： global（g）：全局匹配 ignoreCase（i）：忽略大小写 multiline（m）：多行匹配 12345678910var reg = /\d+/g;var str = 'iceman2016learn2017';console.log(reg.lastIndex); // 0console.log(reg.exec(str)); // ["2016", index: 6, input: "iceman2016learn2017"]console.log(reg.lastIndex); // 10console.log(reg.exec(str)); // ["2017", index: 15, input: "iceman2016learn2017"]console.log(reg.lastIndex); // 19console.log(reg.exec(str)); // null 在加了修饰符g之后，就解决了懒惰型，达到了我们想要的效果，所以全局修饰符g的原理是：正则每一次捕获结束后，lastIndex的值都变成了最新的值，下一次捕获从最新的位置开始查找，这样就可以把所有需要捕获的内容都获取到了。 5.2 贪婪性123var reg = /\d+/g; // 出现一到多个0~9之间的数字var str = 'iceman2016learn2017javascript2018';console.log(reg.exec(str)); // ["2016", index: 6, input: "iceman2016learn2017javascript2018"] 正则的内容是/\d+/，是匹配1到多个数字，2015是符合正则的，但是2也是符合正则的，为什么默认就捕获了2016呢？ 这就是正则的贪婪性。 如何解决？ 在量词元字符后面添加一个”?”即可。 123456789var reg = /\d+?/g; // 出现一到多个0~9之间的数字var str = 'iceman2016learn2017javascript2018';console.log(reg.exec(str)); // ["2", index: 6, input: "iceman2016learn2017javascript2018"]var ary = [] , res = reg.exec(str);while (res) &#123; ary.push(res[0]); res = reg.exec(str)&#125;console.log(ary); // ["0", "1", "6", "2", "0", "1", "7", "2", "0", "1", "8"] “?”在正则中的作用： 放在一个普通的元字符后面，代表出现0~1次； 放在一个量词的元字符后面，取消捕获时候的贪婪性； 5.3 字符串中的match方法match方法的作用是，把所有和正则匹配的字符都获取到。 1234var reg = /\d+?/g;var str = 'zhufeng2015peixun2016dasgdas2017';var ary = str.match(reg);console.log(ary); // ["2", "0", "1", "5", "2", "0", "1", "6", "2", "0", "1", "7"] 注意：虽然在当前的情况下，match比exec更加的简洁一些，但是match存在一些自己处理不了的问题：在分组捕获的情况下，match只能捕获到大正则，而对于小正则捕获的内容是无法获取的。 6. 分组捕获6.1 正则分组正则分组的两个作用： 改变优先级 分组引用 \2代表和第二个分组出现一模一样（和对应的分组中的内容和值都要一样）的内容; \1代表和第一个分组出现一模一样的内容； 123var reg = /^(\w)(\w)\1\2$/;console.log(reg.test("icic")); // trueconsole.log(reg.test("r0g_")); // false 6.2 分组捕获正则在捕获的时候，不仅仅把大正则匹配的内容捕获到，而且还可以把小分组匹配的内容捕获到。 身份证中的数字都有意义的，比如开头的两位代表省，中间的四位代表…所以对于一个身份中，有必要对其中的数字按照其意义进行分组捕获。 123var reg = /^(\d&#123;2&#125;)(\d&#123;4&#125;)(\d&#123;4&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)(?:\d&#123;2&#125;)(\d)(?:\d|X)$/;var str = "350324202904190216";console.log(reg.exec(str)); 注意：(?:) 在分组中?:的意思是只匹配不捕获 输出的内容为：[“350324200904190216”, “35”, “0324”, “2009”, “04”, “19”, “1”, index: 0, input: “350324200904190216”] 其中： 350324200904190216 ：大正则匹配的内容 35 ：第一个分组捕获的内容 0324 ：第二个分组捕获的内容 …… 在这里使用match方法的话，和exec获取的内容一样： 1console.log(str.match(reg)); 另一个例子： 123456789var reg = /ice(\d+)/g;var str = 'ice1234ice3456ice5678'// 用exec执行三次，每一次不仅仅把大正则匹配的获取到，而且还可以获取第一个分组匹配的内容console.log(reg.exec(str)); // ["ice1234", "1234", index: 0, input: "ice1234ice3456ice5678"]console.log(reg.exec(str)); // ["ice3456", "3456", index: 7, input: "ice1234ice3456ice5678"]console.log(reg.exec(str)); // ["ice5678", "5678", index: 14, input: "ice1234ice3456ice5678"]// 而match只能捕获大正则console.log(str.match(reg)); // ["ice1234", "ice3456", "ice5678"] 此时match是只能捕获大正则的内容，所以match能做到的exec都能做到，match做不到的exec也能做到。 总结：只捕获一次就好的，那么用exec和match都可以，像本例中要连续捕获三次的，用match就捕获不到小正则了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[总结一些Sublime Text3使用技巧]]></title>
      <url>%2F2017%2F02%2F26%2F2017-02-26-Sublime%20Text3%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
      <content type="text"><![CDATA[Sublime Text 是很多人喜欢的代码编辑器，掌握一些快捷键，能让你打码更有效率。本篇笔记向大家介绍Sublime Text编辑器一些常用的快捷技巧，希望对大家有所帮助。 1. Goto Anything：Ctrl+P 功能1：Ctrl +P 快速查询文件（支持模糊匹配），如：public/index.html； 功能2：@可以快速查询css中的选择器或js中的函数； #匹配页面标签 功能3：模糊匹配，如设置background-color属性，仅输入bgc即可。 2. 多行游标 功能：快速替换，快速添加。 (1) 普通方法： Ctrl + H：Find what（想要替换），Replace what（替换成什么）中完成替换； (2) 快捷方法： ​ 选中第一个匹配项，使用Ctrl+D选中下一个，依次使用Ctrl +D选中所有想要替换的文本（Crtl + K 可跳过中间某一个不想选中的），可以看到每一个文本后面都有了闪动的光标，输入替换内容即可； ​ 也可用上述方法同时在不同的模块下添加多行新的配置项（Find Replace不能完成的功能）。 如何产生多行游标： Ctrl +D（Ctrl+K跳过）； 选中第一个，再按Alt+F3整页选中所有匹配项； 拆行方式，先Ctrl + A，再Ctrl+Shift+L； 拖动方式：按住Shift +鼠标右键，向下拖动产生多行游标； 3. 命令模式：Ctrl+Shift+P（模糊匹配） 功能：修改编辑区的语法模式、安装插件、隐藏/显示minimap 修改语法模式：输入ss（Set Syntax）+语法模式，如ssJavaScript、ssphp、ssjava或JavaScript、java等，即可改变文件类型。 4. PackageControl安装插件 官网：https://sublime.wbond.net 复制代码 View &gt; Show Console黏贴代码，重新启动 Ctrl + Shift + P启动命令模式，输入pc（Package Control），选择Install Package安装插件 5. snippets以模板的方式编程（以js为例） 功能1：快速生成函数 第一步：Ctrl + Shift + P启动命令模式，输入ssjs切换语法模式； 第二步：写一个函数，Ctrl + Shift + P启动命令模式，输入snip; ​ 第三步：选择snippets:Function，回车，即可自动生成函数； 第四步：直接修改函数名，再使用tab键，即可看到光标在argument参数部分高亮显示，即可修改参数，再一次按tab键，就跳转到函数体部分。Tab键的使用减少了移动光标的操作。 功能2：自动补全 例1：fun + Enter 例2：ife + Enter 例3：Prototypre 定义一个构造函数Person： Person类定义一个实例函数，使用原型链，只需要输入一个Prototype+Enter，修改相应内容即可。 6. 几个其他常用快捷键 Ctrl+Shift+D ————复制光标所在整行，插入到下一行。 Ctrl+Shift+V ————-粘贴过程中保持缩进 Ctrl+Shift+K ————-删除整行。 Ctrl+Shift+Enter——–在上一行插入新行 Ctrl+Enter —————-在下一行插入新行。即使光标不在行尾，也能快速向下插入一行。 Ctrl + W ——————-关闭当前文档 Ctrl + ] ———————右缩进 Ctrl + [ ———————左缩进 Alt + . ———————-快速闭合标签 !+Ctrl+E——————–快速生成html完整标记（Emmet插件） ul&gt;.item$*10 + Ctrl + E————-产生多个无序列表： 参考链接 ： http://blog.jobbole.com/82527/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于Chrome自带的开发者工具你不知道的事]]></title>
      <url>%2F2017%2F02%2F22%2F2017-02-22-%E5%85%B3%E4%BA%8EChrome%E8%87%AA%E5%B8%A6%E7%9A%84%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B%2F</url>
      <content type="text"><![CDATA[今天早上，在FreeCodeCamp公众号中看到了一篇关于Chrome自带开发者工具的文章。以前自己也只是知道一点点最简单的功能，看完觉得特别有用，记录一下。 原文链接：https://zhuanlan.zhihu.com/p/22665710 选取DOM元素jQuery中，我们一般用 (&#39;tagName&#39;)、 (&#39;.class&#39;)、$(&#39;#id&#39;)等选择器选取DOM元素，它们都相当于原生js的document.querySelector()方法。返回的第一个匹配选择规则的DOM元素。 在Chrome的控制台里，你可以通过 $$(&#39;tagName&#39;) 或者 $$(&#39;.className&#39;)， 即两个$$符号来选择所有匹配规则的DOM元素。返回的结果是一个数组，然后可以通过数组的方法来访问其中的单个元素。 比如：$$(&#39;className&#39;) 会返回给你所有包含 className 类属性的元素，之后你可以通过 $$(&#39;className&#39;)[0] 和$$(&#39;className&#39;)[1] 来访问其中的某个元素。 直接在浏览器里更改网页的文本内容以前，我也是右键审查元素，然后编辑源代码。但是现在，只需要在控制台中输入document.body.contentEditable = true, 就可以直接在网页中编辑文本内容。 获取某个DOM元素绑定的事件通过getEventListeners($(&#39;selector&#39;)) 方法以数组对象的格式返回某个元素绑定的所有事件。你可以在控 制台里展开对象查看详细的内容。 选择其中的某个事件，可以通过下面的方法来访问：getEventListeners($(&#39;selector&#39;)).eventName[0].listener ，这里的 eventName 表示某种事件类型。比如： getEventListeners($(&#39;#firstName&#39;)).click[0].listener会返回ID为firstName元素绑定的click事件。 监测事件monitorEvents($(&#39;selector&#39;)) 会监测某个元素上绑定的所有事件，一旦该元素的某个事件被触发就会在控制台里显示出来。 monitorEvents($(&#39;selector&#39;),&#39;eventName&#39;) 可以监听某个元素上绑定的具体事件。第二个参数代表事件类型的名称。例如 monitorEvents($(&#39;#firstName&#39;),&#39;click&#39;) 只监测ID为firstName的元素上的click事件。 monitorEvents($(&#39;selector&#39;),[&#39;eventName1&#39;,&#39;eventName3&#39;,….]) 同上。可以同时检测具体指定的多个事件类型。 unmonitorEvents($(&#39;selector&#39;)) 用来停止对某个元素的事件监测。 用计时器来获取某段代码块的运行时间通过 console.time(&#39;labelName&#39;) 来设定一个计时器，其中的 labelName是计时器的名称。通过console.timeEnd(&#39;labelName&#39;)方法来停止并输出某个计时器的时间。 ​结合上述两种方法，可以计算代码块运行时间。 以表格的形式输出数组直接在控制台里输入数组的名称，Chrome会以文本的形式返回一个数组对象。但你完全可以通过console.table(variableName) 方法来以表格的形式输出每个元素的值。variableName是数组名。 通过控制台方法来检查元素inspect($(&#39;selector&#39;)) 会检查所有匹配选择器的DOM元素，并返回所有选择器选择的DOM对象。例如inspect($(&#39;#firstName&#39;))选择所有ID是 firstName 的元素，inspect($$(&#39;p&#39;)[3]) 检查并返回页面上第四个p元素。 $0, $1, $2等等会返回你最近检查过的几个元素，例如$1会返回你最后检查的元素，$2则返回倒数第二个。 列出某个元素的所有属性dir($(&#39;selector&#39;))会返回匹配选择器的DOM元素的所有属性，你可以展开输出的结果查看详细内容。 获取最后计算结果的值在Chrome控制台里进行计算时，可以通过$_来获取最后的计算结果值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery 选择器全解]]></title>
      <url>%2F2017%2F02%2F21%2F2017-02-21-jQuery%20%E9%80%89%E6%8B%A9%E5%99%A8%E5%85%A8%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[通俗的讲, Selector选择器就是”一个表示特殊语意的字符串”。只要把选择器字符串传入上面的方法中就能够选择不同的 Dom 对象并且以 jQuery 包装集的形式返回。 jQuery 选择器按照功能主要分为”选择”和”过滤”，并且是配合使用的，可以同时使用组合成一个选择器字符串。 主要的区别是”过滤”作用的选择器是指定条件从前面匹配的内容中筛选,”过滤”选择器也可以单独使用, 表示从全部”*”中筛选. 比如:$(&quot;:[title]&quot;)等同于$(&quot;*:[title]&quot;),而”选择”功能的选择器则不会有默认的范围,因为作用是”选择”而不是”过滤”。 ​ 下面的选择器分类中, 带有”过滤器”的分类表示是”过滤”选择器,否则就是”选择”功能的选择器。jQuery 选择器分为如下几类: ● 基础选择器 Basics ● 层次选择器 Hierarchy ● 基本过滤器 Basic Filters ● 内容过滤器 Content Filters ● 可见性过滤器 Visibility Filters ● 属性过滤器 Attribute Filters ● 子元素过滤器 Child Filters ● 表单选择器 Forms ● 表单过滤器 Form Filters]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HEXO+Github 搭建个人博客]]></title>
      <url>%2F2017%2F02%2F21%2F2017-02-21-HEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[刚刚接触hexo，喜欢其简约的风格，因此想着自己也搭建一个。网上使用hexo搭建博客的教程很多，我自己也跟着别人的教程一步步的搭建了属于自己的博客。基本上只要是有点计算机基础的人，完全可以轻松的使用hexo搭建起自己的博客。记录一下自己的历程，算是个人笔记吧。 hexo是一款基于Node.js的静态博客框架, hexo github链接 ,这篇笔记主要是针对windows系统进行搭建的。 ​ 准备工作安装Node作用：用来生成静态页面。 Node.js官网：Node.js 安装Git作用：把本地的hexo内容提交到github上去。 Git官网：Git 初始配置，请看Git学习笔记 Github账号申请作用：是用来做博客的远程创库、域名、服务器之类的。 安装Hexo使用以下命令安装hexo到全局 1$ sudo npm install -g hexo 然后输入命令 hexo -v输出hexo的版本号即为安装成功。 博客搭建初始化在某个地方新建一个项目文件夹（比如Blog），然后进入Blog目录，以下所有的命令行操作都是在这个文件夹下进行的。 1hexo init 生成静态页面初始化完成之后，就已经生成一篇”hello word”的文章了，现在执行以下命令把文章编译为静态页面： 1hexo generate（hexo g 也可以） 本地启动把文章变为页面之后，可以执行以下命令，本地启动服务，在浏览器中输入http://localhost:4000/查看生成的页面效果。 1hexo server（或hexo s） 如果你看到了下面这个画面，恭喜你，你成功了！ 若不能看到上面页面，说明环境还没配置好 先执行 1$ npm install hexo-server --save 再执行： 1$ hexo server 得到: INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 然后在浏览器中输入http://localhost:4000/，便可看到生成的静态页面。 更换主题上面的博客效果是hexo自己默认的主题landscape，我将它修改成yilia主题 clone主题代码在主目录下执行下面的命令clone主题代码： 1$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 修改配置文件注意：修改的时候，每个冒号后面都需要留一个英文空格，不然会报错！ 修改Blog/_config.yml文件： 1theme: yilia //默认为landscape 修改themes/yilia/_config.yml文件： 更改主题之后可以使用命令hexo server打开本地服务，查看效果。 部署到Github上建立Repository建立与你用户名对应的仓库，仓库名必须为[your_user_name.github.io]，固定写法。 修改配置文件部署之前先修改Blog/_config.yml文件，注意: 后面要有空格： 1234deploy: type: git repository: https://github.com/your_user_name/your_user_name.github.io.git branch: master 然后使用以下命令进行部署： 1$ hexo deploy 如果执行上述命令报错，你可以试试下面这个命令再试： 1$ npm install hexo-deployer-git --save 然后再浏览器中输入https://wenhuiyang-luck.github.io/ 就行了。把wenhuiyang-luck换成你的名字即可。 后期部署步骤搭建完成之后，通过以下简单命令，就可以维护自己的博客： 12345$ hexo new(n) xxx //写文章$ hexo clean //清除缓存$ hexo generate(g) //把文章生成页面$ hexo server(s) //启动本地服务调试$ hexo deploy(d) //部署到github 可与hexo g合并为 hexo d -g ##### **遇到的问题：标签和分类无法显示，怎么解决？ 新建一个页面，命名为tags。命令如下：会在blog\source\下生成一个名为tags的文件夹，打开里面的index.md，添加内容，如下： ​ 如果启用多说评论，默认页面会带有评论。需要关闭的话，就加上comment: false.注意：冒号后有一个空格。 当$ hexo new xxx一篇新的文章，在新生成的.md文章默认格式title下添加tags字段，如下图: ​ “Git”是你的标签名，若为多个标签，写成如下形式：tags: [tag1,tag2,tag3] ​ 分类(categories)的设置与上面一样。 更详细教程，请参考：http://www.jianshu.com/p/f4cc5866946b]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git学习笔记]]></title>
      <url>%2F2017%2F02%2F21%2F2017-02-20-Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。 Git官网 http://git-scm.com/ Git 初始设置全局设置用户名和Email 1git config --global user.name "your name" 1git config --global user.email "you@yourdomain.example.com" 新建仓库创建新文件夹，打开，然后执行以下命令创建新的git仓库。 1git init 检出仓库执行如下命令以创建一个本地仓库的克隆版本： 1git clone /path/to/repository 如果是远端服务器上的仓库，命令如下： 1git clone username@host:/path/to/repository 工作流你的本地仓库由git维护的三棵“树”组成。第一个是你的工作目录，它持有实际文件；第二个是缓存区（Index），它像个缓存区域，临时保存你的改动；最后是HEAD，指向你最近一次提交后的结果。 添加与提交你可以计划改动（把它们添加到缓存区），使用如下命令： 1git add &lt;filename&gt; 1git add * 这是git基本工作流程的第一步；使用如下命令以实际的提交改动： 1git commit -m "代码提交信息" 现在，你的改动已经提交到HEAD，但是还没有到你的远端仓库。 推送改动你的改动现在已经在本地仓库的HEAD中了。执行如下命令以将这些改动提交到远端仓库： 1git push origin master 可以把 master 换成你想要推送的任何分支。 如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加： 1git remote add origin &lt;server&gt; 如此你就能够将你的改动推送到所添加的服务器上去了。 分支分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master 是“默认的”。在其他分支上进行开发，完成后再将它们合并到主分支上。 创建一个叫做“feature_x”的分支，并切换过去： 1git checkout -b feature_x 切换回主分支： 1git checkout master 再把新建的分支删掉： 1git branch -d feature_x 除非你将分支推送到远端仓库，不然该分支就是 不为他人所见的： 1git push origin &lt;branch&gt; 更新与合并 要更新你的本地仓库至最新改动，执行： 1git pull 以在你的工作目录中 获取（fetch） 并 合并（merge） 远端的改动。 要合并其他分支到你的当前分支（例如 master），执行： 1git merge &lt;branch&gt; 两种情况下，git都会尝试去自动合并改动。不幸的是，自动合并并非次次都能成功，并可能导致 冲突（conflicts）。 这时候就需要你修改这些文件来人肉合并这些 冲突（conflicts） 了。改完之后，你需要执行如下命令以将它们标记为合并成功： 1git add &lt;filename&gt; 在合并改动之前，也可以使用如下命令查看： 1git diff &lt;source_branch&gt; &lt;target_branch&gt; 替换本地改动 假如你做错事（自然，这是不可能的），你可以使用如下命令替换掉本地改动： 1git checkout -- &lt;filename&gt; 此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到缓存区的改动，以及新文件，都不受影响。 假如你想要丢弃你所有的本地改动与提交，可以到服务器上获取最新的版本并将你本地主分支指向到它： 1git fetch origin 1git reset --hard origin/master]]></content>
    </entry>

    
  
  
</search>
